--!native
--!optimize 2

------------------------------------------------------------
-- OSGL v1.3b - Open-Source-Graphical-Library
-- Copyright © 2023-2024 Gunshot Sound Studios (@saaawdust)
--
-- This software is provided ‘as-is’, without any express or implied warranty.
-- In no event will the authors be held liable for any damages arising from the use of this software.
--
-- Permission is granted to anyone to use this software for any purpose,
-- including commercial applications, and to alter it and redistribute it freely,
-- subject to the following restrictions:
--
-- 1. The origin of this software must not be misrepresented;
--    you must not claim that you wrote the original software.
--    If you use this software in a product, an acknowledgment
--    in the product documentation would be appreciated but is not required.
--
-- 2. Altered source versions must be plainly marked as such,
--    and must not be misrepresented as being the original software.
--
-- 3. This notice may not be removed or altered from any source distribution.
--
------------------------------------------------------------

local OSGL = script.Parent.Parent.Parent
local types = require(OSGL.types)
local log = require(OSGL.log)
local PixelStorage = require(OSGL.DrawableObject).PixelStorage

--[=[
    @class Texture

    The Texture class. Handles loading textures into memory
    for further use with sprites. Inherits everything from [DrawableObject].
]=]
local Texture = {}

local function loadTxt<P>(txt: types.FlagTexture): types.Texture<P>
    local pixelStorage = PixelStorage.new(txt.width, txt.height)
    local i = 0
    for _, v in ipairs(txt.pixels) do
        if type(v) == "number" then
            pixelStorage:WriteIndex(i, v)
            -- just offsetting by 1 pixel.
            i = pixelStorage:OffsetIndex(i, 1, 0, 0)
        else
            -- This is a flag. For now, there's only an `r` flag.
            local repetitions, color = string.match(v, "(%d+)-(%d+)")
            for _ = 1, repetitions do
                pixelStorage:WriteIndex(i, color)
                -- just offsetting by 1 pixel.
                i = pixelStorage:OffsetIndex(i, 1, 0, 0)
            end
        end
    end

    return {
        pixelStorage = pixelStorage,
        sizeX = txt.width,
        sizeY = txt.height,
        size = Vector2.new(txt.width, txt.height)
    }
end

--[=[
    Loads a texture from a string, or a module that returns a string.

    ```lua
    local OSGL = require(path.to.osgl)
    local Window = OSGL.Window
    local texture = OSGL.texture
    ​
    -- Creates a window from an existing EditableImage
    local myWindow = Window.from(path.to.editableImage, { sizeX = 50, sizeY = 50 })

    local txt = texture.from(script.ModuleThatReturnsTexture)
    ```

    @within Texture
    @param textureData FlagTexture | ModuleScript -- The string that was generated by the `converter` exe
]=]
function Texture.from<P>(textureData: types.FlagTexture | ModuleScript): types.Texture<P>
	if type(textureData) ~= "table" and textureData:IsA("ModuleScript") then
		textureData = require(textureData) -- Assuming it's an array
	end

	return loadTxt(textureData)
end

--[=[
    Creates a texture of the given width and height

    ```lua
    local OSGL = require(path.to.osgl)
    local Window = OSGL.Window
    local texture = OSGL.texture
    ​
    -- Creates a window from an existing EditableImage
    local myWindow = Window.from(path.to.editableImage, { sizeX = 50, sizeY = 50 })

    local txt = texture.new(50, 50)
    ```

    @within Texture
    @param sizeX number -- The width of the texture
    @param sizeY number -- The height of the texture
    @return Texture -- The final texture
]=]
function Texture.new<P>(sizeX: number, sizeY: number): types.Texture<P>
	return {
        pixelStorage = PixelStorage.new(sizeX, sizeY),
        sizeX = sizeX,
        sizeY = sizeY,
    }
end

function getIndicesInRange(size: number, width: number, x: number, y: number, sizeX: number, sizeY: number)
    local indices = table.create(size, -1)
    for j = 0, sizeY - 1 do
        for i = 0, sizeX - 1 do
            local index = ((y + j) * width + (x + i)) + 1
            table.insert(indices, index)
        end
    end
    return indices
end

--[=[
    Reads the desired chunk from a DrawableObject object

    ```lua
    local OSGL = require(path.to.osgl)
    local Window = OSGL.Window
    local texture = OSGL.texture
    ​
    -- Creates a window from an existing EditableImage
    local myWindow = Window.from(path.to.editableImage, { sizeX = 50, sizeY = 50 })

    -- *Draw somthing here*

    -- Read a 5x5 square chunk, with the top-left corner
    -- being at 0, 0. This will return an array of colors
    -- of length 25 (assuming the window isn't smaller than 5x5 pixels)
    print(texture.read(myWindow, 0, 0, 5, 5))
    ```

    @within Texture
    @param from DrawableObject -- The [DrawableObject] that will be read
    @param x number -- The X position of the area that will be read
    @param y number -- The position of the area that will be read
    @param xSize number? -- The X-Size of the chunk. Defaults to 1
    @param ySize number? -- The Y-Size of the chunk. Defaults to 1
    @error "X" -- This error occurs if the X is less than 0
    @error "Y" -- This error occurs if the Y is less than 0
    @error "XSize" -- This error occurs if the XSize is less than 1
    @error "YSize" -- This error occurs if the YSize is less than 1
    @return {types.Color} -- The colors in the specified chunk
]=]
function Texture.read<P>(from: types.DrawableObject<P>, x: number, y: number, xSize: number?, ySize: number?): {types.Color}
    xSize = xSize or 1
    ySize = ySize or 1

    log.cassert(x >= 0, "The X must be bigger or equal to 0")
    log.cassert(y >= 0, "The Y must be bigger or equal to 0")
    log.cassert(xSize >= 1, "The XSize must be bigger or equal to 1")
    log.cassert(ySize >= 1, "The XYsize must be bigger or equal to 1")

    local size = (xSize * ySize) / 2
    local colors = table.create(size, 0)
    local pixels = from.pixels
    local indices = getIndicesInRange(size, from.sizeX, x, y, xSize, ySize)
    for i, v in ipairs(indices) do
        if v == -1 then continue end
        colors[i] = pixels[v]
    end

    return colors
end

return Texture
