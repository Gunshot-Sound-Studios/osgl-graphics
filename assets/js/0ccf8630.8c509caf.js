"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[502],{3905:(e,n,a)=>{a.d(n,{Zo:()=>p,kt:()=>m});var t=a(67294);function r(e,n,a){return n in e?Object.defineProperty(e,n,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[n]=a,e}function o(e,n){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var t=Object.getOwnPropertySymbols(e);n&&(t=t.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),a.push.apply(a,t)}return a}function i(e){for(var n=1;n<arguments.length;n++){var a=null!=arguments[n]?arguments[n]:{};n%2?o(Object(a),!0).forEach((function(n){r(e,n,a[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):o(Object(a)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(a,n))}))}return e}function l(e,n){if(null==e)return{};var a,t,r=function(e,n){if(null==e)return{};var a,t,r={},o=Object.keys(e);for(t=0;t<o.length;t++)a=o[t],n.indexOf(a)>=0||(r[a]=e[a]);return r}(e,n);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(t=0;t<o.length;t++)a=o[t],n.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(r[a]=e[a])}return r}var s=t.createContext({}),d=function(e){var n=t.useContext(s),a=n;return e&&(a="function"==typeof e?e(n):i(i({},n),e)),a},p=function(e){var n=d(e.components);return t.createElement(s.Provider,{value:n},e.children)},c="mdxType",u={inlineCode:"code",wrapper:function(e){var n=e.children;return t.createElement(t.Fragment,{},n)}},w=t.forwardRef((function(e,n){var a=e.components,r=e.mdxType,o=e.originalType,s=e.parentName,p=l(e,["components","mdxType","originalType","parentName"]),c=d(a),w=r,m=c["".concat(s,".").concat(w)]||c[w]||u[w]||o;return a?t.createElement(m,i(i({ref:n},p),{},{components:a})):t.createElement(m,i({ref:n},p))}));function m(e,n){var a=arguments,r=n&&n.mdxType;if("string"==typeof e||r){var o=a.length,i=new Array(o);i[0]=w;var l={};for(var s in n)hasOwnProperty.call(n,s)&&(l[s]=n[s]);l.originalType=e,l[c]="string"==typeof e?e:r,i[1]=l;for(var d=2;d<o;d++)i[d]=a[d];return t.createElement.apply(null,i)}return t.createElement.apply(null,a)}w.displayName="MDXCreateElement"},70951:(e,n,a)=>{a.r(n),a.d(n,{assets:()=>s,contentTitle:()=>i,default:()=>u,frontMatter:()=>o,metadata:()=>l,toc:()=>d});var t=a(87462),r=(a(67294),a(3905));const o={},i=void 0,l={unversionedId:"Migrating/Migration",id:"Migrating/Migration",title:"Migration",description:"Welcome to the migration guide for transitioning from CanvasDraw to OSGL. This guide will walk you through the key steps and changes needed to migrate your existing codebase smoothly from CanvasDraw to OSGL.",source:"@site/docs/Migrating/Migration.md",sourceDirName:"Migrating",slug:"/Migrating/Migration",permalink:"/osgl-graphics/docs/Migrating/Migration",draft:!1,editUrl:"https://github.com/Gunshot-Sound-Studios/osgl-graphics/edit/main/docs/Migrating/Migration.md",tags:[],version:"current",frontMatter:{},sidebar:"defaultSidebar",previous:{title:"Drawing Shapes",permalink:"/osgl-graphics/docs/Shapes/drawing-shapes"},next:{title:"Planned updates",permalink:"/osgl-graphics/docs/Whats Next/planned-updates"}},s={},d=[],p={toc:d},c="wrapper";function u(e){let{components:n,...a}=e;return(0,r.kt)(c,(0,t.Z)({},p,a,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Welcome to the migration guide for transitioning from CanvasDraw to OSGL. This guide will walk you through the key steps and changes needed to migrate your existing codebase smoothly from CanvasDraw to OSGL."),(0,r.kt)("p",null,"It's important to note that OSGL and CanvasDraw's internal architecture is ",(0,r.kt)("strong",{parentName:"p"},"different"),". OSGL works completely differently to CanvasDraw, and vice-versa. You may need to refactor your code."),(0,r.kt)("p",null,"In CanvasDraw, you create objects known as canvases, with ",(0,r.kt)("inlineCode",{parentName:"p"},"CanvasDraw.new()"),". You can replicate this in OSGL by creating a ",(0,r.kt)("strong",{parentName:"p"},"window"),", which you can read about ",(0,r.kt)("a",{parentName:"p",href:"/osgl-graphics/docs/Windows/opening-a-window"},"here"),":"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-lua"},"local CanvasDraw = require(path)\nlocal OSGL = require(path)\nlocal Window = OSGL.Window -- OSGL is broken down into sub-modules that handle different aspects\n\n-- CanvasDraw\nCanvasDraw.new(Parent, Resolution, Color, Blur)\n\n-- OSGL\nWindow.new(Parent, { sizeX = width, sizeY = height })\n")),(0,r.kt)("p",null,"You can utilize the ",(0,r.kt)("inlineCode",{parentName:"p"},"Window.new")," function to create the equivilent of a CanvasDraw canvas, in OSGL. The OSGL code creates an EditableImage of size: ",(0,r.kt)("inlineCode",{parentName:"p"},"(sizeX, sizeY)"),"."),(0,r.kt)("p",null,"All drawing methods can be directly accessed straight from the ",(0,r.kt)("inlineCode",{parentName:"p"},"Canvas")," object; which is not the case in OSGL. As shown in the code-example above, OSGL is broken down into different sub-modules that each do their own thing (e.g handling color, drawing, loading textures, etc.). Comparison example:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-lua"},"local CanvasDraw = require(path)\nlocal OSGL = require(path)\nlocal Window = OSGL.Window\nlocal color = OSGL.color\nlocal draw = OSGL.draw\n\n-- Draw a red pixel\nlocal Canvas = CanvasDraw.new(Frame, Vector2.new(150, 100))\nCanvas:DrawPixel(Vector2.new(75, 50), Color3.new(1, 0, 0))\n\n-- Draw a red pixel\nlocal window = Window.new(Frame, { sizeX = 150, sizeY = 100 })\ndraw.pixel(window, 76, 51, color.RED)\n")),(0,r.kt)("p",null,"It's also important to note 2 things:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"In OSGL, the top-left corner of the window is (0,0). In CanvasDraw, it is (1, 1)"),(0,r.kt)("li",{parentName:"ul"},"The ",(0,r.kt)("inlineCode",{parentName:"li"},"draw")," module is not needed to draw onto the window")),(0,r.kt)("p",null,"Similarly to CanvasDraw, you can draw any shape via method, however OSGL allows you to chain these methods:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-lua"},'local Canvas = CanvasDraw.new(Frame, Vector2.new(150, 100))\nCanvas:DrawPixel(Vector2.new(75, 50), Color3.new(1, 0, 0))\nCanvas:DrawLine(Vector2.new(5, 5), Vector2.new(145, 95), Color3.new(1, 0, 0), 2, true)\n\nlocal window = Window.new(Frame, { sizeX = 150, sizeY = 100 })\nwindow\n    :Draw() -- Opens a "DrawingContext". \n    :Pixel(76, 51, color.RED)\n    :Line(6, 6, 146, 96, 2, color.RED)\n    :StopDrawing() -- If you want to access the window\'s methods, you can use this.\n                   -- Else, it is not needed!\n')),(0,r.kt)("p",null,"These methods are exactly the same as the ",(0,r.kt)("inlineCode",{parentName:"p"},"Draw")," methods, but they automatically pass the window as the first argument."),(0,r.kt)("p",null,"You can find more about these methods in the ",(0,r.kt)("inlineCode",{parentName:"p"},"API"),"."),(0,r.kt)("p",null,"Both ",(0,r.kt)("inlineCode",{parentName:"p"},"Window"),"s, and ",(0,r.kt)("inlineCode",{parentName:"p"},"Texture"),"s are something known as a ",(0,r.kt)("inlineCode",{parentName:"p"},"DrawableObject"),". Effectively, a ",(0,r.kt)("inlineCode",{parentName:"p"},"Window")," is just a special form of a ",(0,r.kt)("inlineCode",{parentName:"p"},"Texture"),", and by extent, all a ",(0,r.kt)("inlineCode",{parentName:"p"},"Texture")," is, is a ",(0,r.kt)("inlineCode",{parentName:"p"},"buffer")," containing pixel-data. This is similar to CanvasDraw's ",(0,r.kt)("inlineCode",{parentName:"p"},"ImageData"),". If you wanted to save a texture somewhere, all you would have to do is save the ",(0,r.kt)("inlineCode",{parentName:"p"},"buffer"),", and the ",(0,r.kt)("inlineCode",{parentName:"p"},"sizeX")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"sizeY")," (or just the ",(0,r.kt)("inlineCode",{parentName:"p"},"size"),"). Since it's a ",(0,r.kt)("inlineCode",{parentName:"p"},"Texture"),", you can load it back into the game. This exact process can be described by ",(0,r.kt)("a",{parentName:"p",href:"/osgl-graphics/docs/Windows/serializing-and-deserializing"},(0,r.kt)("inlineCode",{parentName:"a"},"Serialization")," and ",(0,r.kt)("inlineCode",{parentName:"a"},"Deserialization")),":"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-lua"},"-- Save.luau\nlocal bfr, width, height = windowOne:Serialize()\n-- *save data*\n\n-- Load.luau\nlocal bfr, width, height = -- *load data*\nwindowTwo:Deserialize(bfr, width, height)\n")),(0,r.kt)("p",null,"You can learn more about this on the designated page linked above."),(0,r.kt)("admonition",{type:"warning"},(0,r.kt)("p",{parentName:"admonition"},"The ",(0,r.kt)("inlineCode",{parentName:"p"},"Deserialize")," function safely scales the size of the buffer. Directly setting the ",(0,r.kt)("inlineCode",{parentName:"p"},"buffer")," to another buffer may cause size errors! It's always safer to use ",(0,r.kt)("inlineCode",{parentName:"p"},"Deserialize"),", however if you are confident that both ",(0,r.kt)("inlineCode",{parentName:"p"},"buffer"),"s will always be the same size, you can directly set the buffer via:"),(0,r.kt)("pre",{parentName:"admonition"},(0,r.kt)("code",{parentName:"pre",className:"language-lua"},"A.buffer = B.buffer\n"))))}u.isMDXComponent=!0}}]);