[{"title":"Introduction","type":0,"sectionRef":"#","url":"/osgl-graphics/docs/intro","content":"","keywords":""},{"title":"What This Documentation Covers​","type":1,"pageTitle":"Introduction","url":"/osgl-graphics/docs/intro#what-this-documentation-covers","content":"In this guide, you'll learn how to: Open a window using OSGL.Draw pixels, shapes, and other graphical elements such as textures to the window. This documentation assumes a basic understanding of Luau. For those new to the language, numerous resources are available for learning. "},{"title":"Drawing Shapes","type":0,"sectionRef":"#","url":"/osgl-graphics/docs/Shapes/drawing-shapes","content":"Drawing Shapes Below is a list of shapes in OSGL as of version 1.4b: Shape\tSupported\tSupports Rotation\tSupports Stroke\tNotesPixel\t✅\tN/A\tN/A Rectangle\t✅\t✅\t✅ Circle\t✅\t✅\t✅\tRotation is only visible at low resolutions. Lines\t✅\tN/A\t❌ Polygon\t✅\tN/A\t✅ Triangle\t✅\tN/A\t✅ Flood Fill\t✅\tN/A\tN/A\tDynamic shape that fills an area All shape-drawing functions are accessible through the draw sub-module of OSGL. The first argument for each function must be a DrawableObject, which can be either a Window or a Texture. Additionally, you will need to provide the necessary parameters to define the shape, such as its position, size, and color. Here is an example of how to draw a square, as defined by the documentation: local OSGL = require(path.to.osgl) local Window = OSGL.Window local color = OSGL.color local draw = OSGL.draw -- Creates a new EditableImage local myWindow = Window.new(path.to.parent, { sizeX = 50, sizeY = 50 }) -- Draws a 5x5 red square at 0, 0 draw.rectangle(myWindow, 0, 0, 5, 5, color.RED) Notes: Rotation: Most shapes support rotation, but in some cases (e.g., circles), the rotation is only visible at low resolutions. Stroke: For shapes that support strokes, you can define both the stroke color and thickness. However, strokes are entirely optional and can be omitted if not needed.","keywords":""},{"title":"Loading Textures","type":0,"sectionRef":"#","url":"/osgl-graphics/docs/Textures/loading-textures","content":"Loading Textures To load file formats such as PNGs, WebPs, etc., OSGL uses its own external tool. The tool is bundled with OSGL on the github releases page, here, named image-converter (previously converter). Pick the one for your OS. If you don't know which to pick, feel free to ask us! note You can get help with the image-converter exe by running it in the command-prompt, with the -h flag! e.g: &gt; image-converter -h The image-converter turns these image formats into OSGLs custom image-format, which you can learn more about here. We can load textures into OSGL with the Texture.from function, which takes the texture generated by the image-converter: local OSGL = require(path.to.osgl) local Texture = OSGL.Texture ​ local txt = Texture.from(script.ModuleThatReturnsTexture) -- &quot;txt&quot; now contains OSGL-Texture data You can also create a blank texture of the given width, and height, with optional texture-data with the Texture.new function: local OSGL = require(path.to.osgl) local texture = OSGL.texture ​ local txt = Texture.new(50, 50) -- Creates a 50x50 texture info Remember, like Windows, Textures can also be drawn to! You can edit a texture like any other window by passing it as the first argument of a draw function. This is because both belong to a superclass named DrawableObject. This means, anything you can draw to a Window, you can also draw to a Texture! danger Textures are expensive to load into memory! Once loaded however, they can be used everywhere. Try to avoid loading Textures too much.","keywords":""},{"title":"Planned updates","type":0,"sectionRef":"#","url":"/osgl-graphics/docs/Whats Next/planned-updates","content":"Planned updates Below is a list of possible upcoming OSGL features: Fonts &amp; Texts","keywords":""},{"title":"Texture","type":0,"sectionRef":"#","url":"/osgl-graphics/api/Texture","content":"","keywords":""},{"title":"Types​","type":1,"pageTitle":"Texture","url":"/osgl-graphics/api/Texture#types","content":" "},{"title":"FlagTexture​","type":1,"pageTitle":"Texture","url":"/osgl-graphics/api/Texture#FlagTexture","content":"&lt;/&gt; type FlagTexture = { width: number, height: number, pixels: {Color | string}, } The representation of a texture made with the converter exe provided with the module. "},{"title":"Functions​","type":1,"pageTitle":"Texture","url":"/osgl-graphics/api/Texture#functions","content":" "},{"title":"from​","type":1,"pageTitle":"Texture","url":"/osgl-graphics/api/Texture#from","content":"&lt;/&gt; Texture.from( textureData: FlagTexture | ModuleScript -- The textureData ) → DrawableObject-- The loaded texture Creates a texture from textureData local OSGL = require(path.to.osgl) local Texture = OSGL.Texture local textureData = require(path.to.texture) local texture = Texture.from(textureData)   "},{"title":"new​","type":1,"pageTitle":"Texture","url":"/osgl-graphics/api/Texture#new","content":"&lt;/&gt; Texture.new( width: number,-- The texture's width height: number,-- The texture's height bfr: buffer?-- An optional buffer for textureData ) → DrawableObject-- The loaded texture Creates a texture of the given dimensions with an optional buffer local OSGL = require(path.to.osgl) local Texture = OSGL.Texture local texture = Texture.new(5, 10)   "},{"title":"draw​","type":1,"pageTitle":"Texture","url":"/osgl-graphics/api/Texture#draw","content":"&lt;/&gt; Texture.draw( object: DrawableObject,-- The object that the texture will be drawn onto texture: DrawableObject,-- The texture that will be drawn spriteX: number,-- The X position of where the texture will be drawn spriteY: number-- The y position of where the texture will be drawn ) → DrawableObject-- The final texture Draws a DrawableObject onto another DrawableObject local OSGL = require(path.to.osgl) local Texture = OSGL.Texture local textureData = require(path.to.texture) local secondTextureData = require(path.to.secondTexture) local textureA = Texture.from(textureData) local textureB = Texture.from(secondTextureData) -- Draw textureB on textureA at 0, 0 local textureC = Texture.draw(textureA, textureB, 0, 0)   "},{"title":"drawRotated​","type":1,"pageTitle":"Texture","url":"/osgl-graphics/api/Texture#drawRotated","content":"&lt;/&gt; Texture.drawRotated( object: DrawableObject,-- The object that the texture will be drawn onto texture: DrawableObject,-- The texture that will be drawn spriteX: number,-- The X position of where the texture will be drawn spriteY: number,-- The y position of where the texture will be drawn rotation: number-- The rotation of the texture ) → DrawableObject-- The final texture Draws a DrawableObject onto another DrawableObject with a rotation. The pivot is at the center of the DrawableObject local OSGL = require(path.to.osgl) local Texture = OSGL.Texture local textureData = require(path.to.texture) local secondTextureData = require(path.to.secondTexture) local textureA = Texture.from(textureData) local textureB = Texture.from(secondTextureData) -- Draw textureB on textureA at 0, 0, rotated 15 degrees local textureC = Texture.draw(textureA, textureB, 0, 0, 15)   "},{"title":"read​","type":1,"pageTitle":"Texture","url":"/osgl-graphics/api/Texture#read","content":"&lt;/&gt; Texture.read( texture: DrawableObject,-- The texture that the selection of pixels will be taken from xPos: number,-- The top-left X position of the selection yPos: number,-- The top-left Y position of the selection width: number,-- The width of the selection box height: number-- The height of the selection box ) → ( buffer, number, number )-- A tuple containing the buffer-data, the width, and height Reads a rectangular selection of pixels from a DrawableObject local OSGL = require(path.to.osgl) local Texture = OSGL.Texture local textureData = require(path.to.texture) local texture = Texture.from(textureData) -- Read a rectangular selection of pixels from 0, 5, with the -- selection being 10x15 (150 pixels, from 0, 5) local bfr, width, height = Texture.read(texture, 0, 5, 10, 15)   "},{"title":"scale​","type":1,"pageTitle":"Texture","url":"/osgl-graphics/api/Texture#scale","content":"&lt;/&gt; Texture.scale( texture: DrawableObject,-- The texture that will be enlarged scaleX: number,-- Scaling for x axis. Defaults to 1 scaleY: number-- Scaling for y axis. Defaults to 1 ) → DrawableObject-- The enlarged texture Scales a DrawableObject by the given amount local OSGL = require(path.to.osgl) local Texture = OSGL.Texture local textureData = require(path.to.texture) local texture = Texture.from(textureData) -- Enlarge `texture` by 5x on the X axis local enlargedTexture = Texture.scale(texture, 5)   "},{"title":"fromAssetId​","type":1,"pageTitle":"Texture","url":"/osgl-graphics/api/Texture#fromAssetId","content":"&lt;/&gt; Texture.fromAssetId( assetId: number-- The assetId that the texture will be ) → DrawableObject-- A finished texture that is the assetId Creates a DrawableObject (texture) from an assetId local OSGL = require(path.to.osgl) local Texture = OSGL.Texture local textureData = require(path.to.texture) local texture = Texture.fromAssetId(asset.id)  "},{"title":"Errors","type":1,"pageTitle":"Texture","url":"/osgl-graphics/api/Texture##","content":"Type\tDescription&quot;Memory&quot;\tThis error occurs when the device doesn't have enough memory to create the texture "},{"title":"Custom OSGL Image-Format","type":0,"sectionRef":"#","url":"/osgl-graphics/docs/Textures/custom-texture-format","content":"","keywords":""},{"title":"Colors​","type":1,"pageTitle":"Custom OSGL Image-Format","url":"/osgl-graphics/docs/Textures/custom-texture-format#colors","content":"Colors are stored as a single 32-bit unsigned integer (u32). This allows for compact representation and fast manipulation of colors in the form of a single number. Each 32-bit color value is structured as four 8-bit components, representing the Red, Green, Blue, and Alpha (opacity) channels of the color. These components are packed into the 32-bit integer, with each component occupying one byte (8 bits). "},{"title":"Byte Layout of the Color​","type":1,"pageTitle":"Custom OSGL Image-Format","url":"/osgl-graphics/docs/Textures/custom-texture-format#byte-layout-of-the-color","content":"The four components are stored in the following order, from the most significant byte to the least significant byte: First byte (bits 1-8): Red (R)Second byte (bits 9-16): Green (G)Third byte (bits 17-24): Blue (B)Fourth byte (bits 25-32): Alpha (A) This can be visualised as: R\tG\tB\tA8 bits\t8 bits\t8 bits\t8 bits 1-8\t9-16\t17-24\t25-32 For example, consider the color with the following components: Red (R): 255 (0xFF) Green (G): 128 (0x80) Blue (B): 64 (0x40) Alpha (A): 255 (0xFF) These components would be packed into a 32-bit integer as follows: Red (R): 255 (0xFF) -&gt; Occupies bits 24-31 Green (G): 128 (0x80) -&gt; Occupies bits 16-23 Blue (B): 64 (0x40) -&gt; Occupies bits 8-15 Alpha (A): 255 (0xFF) -&gt; Occupies bits 0-7 The resulting 32-bit integer representation would be: 0xFF8040FF (4286595327) "},{"title":"Rendering Textures","type":0,"sectionRef":"#","url":"/osgl-graphics/docs/Textures/rendering-textures","content":"","keywords":""},{"title":"Drawing a Texture onto a Window​","type":1,"pageTitle":"Rendering Textures","url":"/osgl-graphics/docs/Textures/rendering-textures#drawing-a-texture-onto-a-window","content":"To render a Texture onto a Window, you can do the exact same thing: local OSGL = require(path.to.osgl) local Window = OSGL.Window local Texture = OSGL.Texture -- Create a new window local myWindow = Window.new(parent, { sizeX = 100, sizeY = 100 }) -- Load a texture local textureData = require(path.to.texture) local myTexture = Texture.from(textureData) -- Draw the texture onto the window at position (10, 10) Texture.draw(myWindow, myTexture, 10, 10) -- Render the window to display it on the screen myWindow:Render()  "},{"title":"Example: Combining Textures with layers​","type":1,"pageTitle":"Rendering Textures","url":"/osgl-graphics/docs/Textures/rendering-textures#example-combining-textures-with-layers","content":"Using this knowledge, you can layer multiple Texture objects onto a singular DrawableObject like so: local OSGL = require(path.to.osgl) local Texture = OSGL.Texture -- Load base texture and 2 additional layers local baseTextureData = require(path.to.baseTexture) local layer1Data = require(path.to.layer1) local layer2Data = require(path.to.layer2) local baseTexture = Texture.from(baseTextureData) local layer1 = Texture.from(layer1Data) local layer2 = Texture.from(layer2Data) -- Draw layer1 onto the base texture at (20, 20) Texture.draw(baseTexture, layer1, 20, 20) -- Draw layer2 onto the updated base texture at (40, 40) Texture.draw(baseTexture, layer2, 40, 40) -- Now baseTexture contains both layers combined!  "},{"title":"Opening a window","type":0,"sectionRef":"#","url":"/osgl-graphics/docs/Windows/opening-a-window","content":"Opening a window In OSGL, a Window is an EditableImage. OSGL is wrapper around this EditableImage that gives you an easy-to-use API with many handy features. Before we can actually draw on our window, we need to create one. OSGL is split into sub-modules that each serve a different purpose (e.g, drawing on a window, creating a window, etc.). In this case, we want the Window class which allows us to create our window. local OSGL = require(ReplicatedStorage.Packages.OSGL) local Window = OSGL.Window There are four functions available for creating our window: Window.from, Window.new, Window.fromAssetId, and Window.fromBuffer. Below is a high-level extract from the API: Window.from : Creates an OSGL window from an existing EditableImage. Window.new : Creates an OSGL window by initializing a new EditableImage instance at the specified location. Window.fromAssetId: Given an assetId, creates a Window. Window.fromBuffer: Given a buffer, creates a Window. Since we don’t have an existing EditableImage and do not wish to use an assetId, nor a buffer, we'll use Window.new to create our window directly on the designated ImageLabel: local OSGL = require(ReplicatedStorage.Packages.OSGL) local Window = OSGL.Window local windowUi = -- *reference to windowUi, our `ImageLabel`* -- Create our window, 500x500 local myWindow = Window.new(windowUi, { sizeX = 500, sizeY = 500 }) The example above creates an OSGL window, with a size of 500x500, under windowUi. You can find more details about this function in the API. And that's it! We have our OSGL window ready and setup for rendering! You can also use Window.from and Window.fromAssetId to create a window. As previously mentioned: Window.fom: Creates an OSGL window from an existing EditableImage. This means if we already have an EditableImage, we can create a window from it: local editableImage = reference.to.editableImage local window = Window.from(editableImage) -- Our window now has `editableImage` as a renderer It's important to remember that a window is actually just an EditableImage in disguise. This means you can actually render to multiple images at the same time, since all a Window does is contain the EditableImage. Window.fromAssetId will create a window, but the contents of the window will be a assetId. danger This function will error if you don't own the asset! Make sure you have the permissions before using this function to avoid errors. The function can be used like Window.new: local window = Window.fromAssetId(asset.id) On the other hand, you can use Window.fromBuffer to create a window with a buffer object already loaded in. This is useful when you are serializing and deserializing many Windows and Textures. You can learn more about this here.","keywords":""},{"title":"Managing & Rendering to a window","type":0,"sectionRef":"#","url":"/osgl-graphics/docs/Windows/managing-and-rendering-to-a-window","content":"Managing &amp; Rendering to a window Now that we have our window, let's make this code a bit more interesting: local OSGL = require(ReplicatedStorage.Packages.OSGL) local Window = OSGL.Window local color = OSGL.color local windowUi -- reference to windowUi, our `ImageLabel` -- Create our window, 500x500 local myWindow = Window.new(windowUi, { sizeX = 500, sizeY = 500 }) myWindow.targetFPS = 270 while task.wait() do myWindow :Clear(color.BLACK) :Render() end In summary, the code above creates a window with a size of 500x500 pixels, with a target FPS of 270. It continuously clears the screen using the BLACK color (0, 0, 0, 255). The Clear method clears the window's buffer with the specified color, and the Render method displays the updated buffer on the screen. It's important to note that the method calls do not need to be chained. You can achieve the same effect with separate statements, as shown below: myWindow:Clear(color.BLACK) myWindow:Render() This sample illustrates that you can call Clear and Render as independent operations if you prefer. The color sub-module is utilized for manipulating colors in OSGL using the RGBA format. Once the window is closed, the program will terminate. In this context, the loop implemented above is often referred to as the &quot;event loop&quot; or &quot;game loop.&quot; The code inside this loop is executed every frame, allowing for continuous updates to the window. While clearing the buffer is one function we can perform, there are many additional operations we can execute within this loop. For instance, we can utilize the draw sub-module to render directly onto the buffer. All drawing functions require a Window or Texture (known as a DrawableObject) to specify where to draw. For example, to draw a pixel, you would use the appropriate draw function provided by OSGL: local OSGL = require(ReplicatedStorage.Packages.OSGL) local Window = OSGL.Window local color = OSGL.color local draw = OSGL.draw local windowUi = -- *reference to windowUi, our `ImageLabel`* -- Create our window, 10x10 local myWindow = Window.new(windowUi, { sizeX = 10, sizeY = 10 }) myWindow.targetFPS = 270 while task.wait() do myWindow:Clear(color.BLACK) -- It isn't necessary to clear the screen. If you want to keep the contents -- of the previous frame, you can! -- Draw a red pixel on `myWindow`, at 0, 0 draw.pixel(myWindow, 0, 0, color.RED) myWindow:Render() end In this example, each operation within the loop is presented as separate statements. However, these statements can be combined into a single statement using method chaining, as shown below: myWindow :Clear(color.BLACK) :Draw() -- Open a `DrawingContext` :Pixel(0, 0, color.RED) -- `myWindow` is automatically passed as the first argument :StopDrawing() :Render() You can learn more about the various shapes you can draw in the Drawing Shapes section! As alluded in the previous section, it's possible to render multiple EditableImages within a single window using the AddRenderer and RemoveRenderer methods. These methods accept various types of Image components, such as ImageLabels, ImageButtons, or any other image-like instances. For example, to add multiple renderers to a window, you can use the AddRenderer method as follows: -- Add two renderers to the window myWindow:AddRenderer(imageLabelOne, imageButtonTwo) This code effectively enables the window to render onto both imageLabelOne and imageButtonTwo, with a minimal performance impact. If you need to remove a renderer, you can do so by passing the instance you wish to remove as an argument to the RemoveRenderer method. Instances that are not currently rendering in the window will be ignored: -- Stop the window from rendering to imageButtonTwo myWindow:RemoveRenderer(imageButtonTwo) ","keywords":""},{"title":"DrawableObject","type":0,"sectionRef":"#","url":"/osgl-graphics/api/DrawableObject","content":"","keywords":""},{"title":"Types​","type":1,"pageTitle":"DrawableObject","url":"/osgl-graphics/api/DrawableObject#types","content":" "},{"title":"DrawableObject​","type":1,"pageTitle":"DrawableObject","url":"/osgl-graphics/api/DrawableObject#DrawableObject","content":"&lt;/&gt; interface DrawableObject { buffer: buffer-- The buffer of the object sizeX: number-- The width of the object. sizeY: number-- The height of the object. size: Vector2 -- The size of the object as a Vector2 Draw: (self: DrawableObject&lt;T&gt;) → DrawingContext&lt;T&gt;-- Returns the drawing context of the object TintRegion: ( self: DrawableObject&lt;T&gt;, tint: Color, factor: number, x: number, y: number, width: number, height: number ) → T-- Tints a region of pixels ReadPixel: ( self: T, x: number, y: number ) → Color-- Reads a pixel at the given X, Y Serialize: (self: T) → ( buffer, number, number )-- Returns the object's buffer, as well as its dimensions } A DrawableObject is an item that you can draw too. This can be a window, or a texture. local OSGL = require(path.to.osgl) local Window = OSGL.Window ​ -- Creates a Window with a size of 50x50 -- This window is a DrawableObject local myWindow = Window.new(path.to.instance, { sizeX = 50, sizeY = 50 })   "},{"title":"DrawingContext​","type":1,"pageTitle":"DrawableObject","url":"/osgl-graphics/api/DrawableObject#DrawingContext","content":"&lt;/&gt; interface DrawingContext { Pixel: ( self: DrawingContext&lt;V&gt;, x: number, y: number, color: Color ) → DrawingContext&lt;V&gt; Line: ( self: DrawingContext&lt;V&gt;, startX: number, startY: number, stopX: number, stopY: number, thickness: number, color: Color ) → DrawingContext&lt;V&gt; Rectangle: ( self: DrawingContext&lt;V&gt;, xPos: number, yPos: number, width: number, height: number, fill: Color?, stroke: Color?, strokeThickness: number?, rotation: number? ) → DrawingContext&lt;V&gt; Circle: ( self: DrawingContext&lt;V&gt;, centerX: number, centerY: number, radius: number, fill: Color?, stroke: Color?, strokeThickness: number?, rotation: number? ) → DrawingContext&lt;V&gt; Triangle: ( self: DrawingContext&lt;V&gt;, x1: number, y1: number, x2: number, y2: number, x3: number, y3: number, fill: Color?, stroke: Color?, strokeThickness: number? ) → DrawingContext&lt;V&gt; Polygon: ( self: DrawingContext&lt;V&gt;, corners: {{number}}, fill: Color ) → DrawingContext&lt;V&gt; FloodFill: ( self: DrawableObject&lt;V&gt;, x: number, y: number, fill: Color ) → DrawingContext&lt;V&gt; StopDrawing: (self: DrawingContext&lt;V&gt;) → V } The DrawingContext is a wrapper around [draw] that allows you to to call the functions with your DrawableObject already passed as the first argument. local OSGL = require(path.to.osgl) local Window = OSGL.Window local color = OSGL.color ​ -- Creates a Window with a size of 50x50 -- This window is a DrawableObject local myWindow = Window.new(path.to.instance, { sizeX = 50, sizeY = 50 }) myWindow:Draw():Pixel(1, 1, color.RED):StopDrawing()  "},{"title":"Properties​","type":1,"pageTitle":"DrawableObject","url":"/osgl-graphics/api/DrawableObject#properties","content":" "},{"title":"buffer​","type":1,"pageTitle":"DrawableObject","url":"/osgl-graphics/api/DrawableObject#buffer","content":"&lt;/&gt; DrawableObject.buffer: buffer The buffer of the object  "},{"title":"sizeX​","type":1,"pageTitle":"DrawableObject","url":"/osgl-graphics/api/DrawableObject#sizeX","content":"&lt;/&gt; DrawableObject.sizeX: number The width of the object  "},{"title":"sizeY​","type":1,"pageTitle":"DrawableObject","url":"/osgl-graphics/api/DrawableObject#sizeY","content":"&lt;/&gt; DrawableObject.sizeY: number The height of the object  "},{"title":"size​","type":1,"pageTitle":"DrawableObject","url":"/osgl-graphics/api/DrawableObject#size","content":"&lt;/&gt; DrawableObject.size: Vector2  The size of the object "},{"title":"Functions​","type":1,"pageTitle":"DrawableObject","url":"/osgl-graphics/api/DrawableObject#functions","content":" "},{"title":"ReadPixel​","type":1,"pageTitle":"DrawableObject","url":"/osgl-graphics/api/DrawableObject#ReadPixel","content":"&lt;/&gt; DrawableObject.ReadPixel( x: number,-- X position y: number-- Y position ) → Color Reads a color on a window at the given location from the buffer local OSGL = require(path.to.osgl) local Window = OSGL.Window local color = OSGL.color -- Creates a new EditableImage local myWindow = Window.new(path.to.parent, { sizeX = 50, sizeY = 50 }) myWindow:WritePixel(0, 0, color.RED):Render() print( myWindow:ReadPixel(0, 0) -- 255 )   "},{"title":"Draw​","type":1,"pageTitle":"DrawableObject","url":"/osgl-graphics/api/DrawableObject#Draw","content":"&lt;/&gt; DrawableObject.Draw() → DrawingContext Returns the Window's DrawingContext local OSGL = require(path.to.osgl) local Window = OSGL.Window local color = OSGL.color -- Creates a new EditableImage local myWindow = Window.new(path.to.parent, { sizeX = 50, sizeY = 50 }) myWindow:Draw():Pixel(1, 1, color.RED):StopDrawing()   "},{"title":"TintRegion​","type":1,"pageTitle":"DrawableObject","url":"/osgl-graphics/api/DrawableObject#TintRegion","content":"&lt;/&gt; DrawableObject.TintRegion() → DrawableObject Tints a region of pixels local OSGL = require(path.to.osgl) local Window = OSGL.Window local color = OSGL.color -- Creates a new EditableImage local myWindow = Window.new(path.to.parent, { sizeX = 50, sizeY = 50 }) myWindow:TintRegion(color.RED, .5, 0, 0, 10, 10) -- Tint pixels from 0, 0, with the -- tinting region being 10x15 (150 pixels, from 0, 0) the color red, with -- a tinting factor of .5   "},{"title":"Serialize​","type":1,"pageTitle":"DrawableObject","url":"/osgl-graphics/api/DrawableObject#Serialize","content":"&lt;/&gt; DrawableObject.Serialize() → ( buffer, number, number ) Returns the object's buffer, as well as its width and height -- Save.luau local bfr, width, height = myWindow:Serialize() -- *save data* -- Load.luau local bfr, width, height = -- *load data* window:Deserialize(bfr, width, height)  "},{"title":"Serializing & Deserializing","type":0,"sectionRef":"#","url":"/osgl-graphics/docs/Windows/serializing-and-deserializing","content":"","keywords":""},{"title":"Why Serialize and Deserialize?​","type":1,"pageTitle":"Serializing & Deserializing","url":"/osgl-graphics/docs/Windows/serializing-and-deserializing#why-serialize-and-deserialize","content":"Imagine you have two Windows: Window A and Window B. You want to copy the contents of A into B. Normally, you'd do something like this: local B = Window.fromBuffer(A.buffer, configuration)  But, here's the catch: if B isn't the same size as A, you'll get an error. That's where serialization and deserialization come in. You can serialize a Window and deserialize it into another Window or even a Texture: local A = Window.new(parent, { sizeX = 50, sizeY = 50 }) -- Draw a texture to `A` local txt = texture.fromAssetId(14419725604) texture.draw(A, txt, 0, 0) -- Serialize `A` to get its buffer, width, and height local bfr, w, h = A:Serialize() local B = Window.new(parentTwo, { sizeX = 2, sizeY = 10 }) -- Resize `B` to match `A`'s dimensions and paste the contents B:Deserialize(bfr, w, h) -- Now `B` has the same size and contents as `A` B:Render()  "},{"title":"What's the Difference?​","type":1,"pageTitle":"Serializing & Deserializing","url":"/osgl-graphics/docs/Windows/serializing-and-deserializing#whats-the-difference","content":"If you're confident about the sizes of the Windows, you can use fromBuffer. But when you're not sure or need to resize dynamically, always use Deserialize. "},{"title":"Serializing Textures​","type":1,"pageTitle":"Serializing & Deserializing","url":"/osgl-graphics/docs/Windows/serializing-and-deserializing#serializing-textures","content":"Textures can also be serialized: local txt = texture.fromAssetId(14419725604) local bfr, w, h = txt:Serialize() -- Create a new window with the texture's contents local window = Window.fromBuffer(bfr, { sizeX = w, sizeY = h }) -- Alternatively, use `Deserialize` to update an existing window: local secondWindow = -- *reference to a window* secondWindow:Deserialize(bfr, w, h)  fromBuffer creates a new Window, while Deserialize updates an existing one. Both approaches get the job done; it just depends on what you need. "},{"title":"Deserializing Textures​","type":1,"pageTitle":"Serializing & Deserializing","url":"/osgl-graphics/docs/Windows/serializing-and-deserializing#deserializing-textures","content":"Unlike Windows, Textures don’t have a Deserialize method. Why? Because you can simply create a new one like this: local txt = texture.fromAssetId(14419725604) local bfr, w, h = txt:Serialize() -- Create a new texture from the serialized data local newTxt = texture.new(w, h, bfr)  "},{"title":"Window","type":0,"sectionRef":"#","url":"/osgl-graphics/api/Window","content":"","keywords":""},{"title":"Types​","type":1,"pageTitle":"Window","url":"/osgl-graphics/api/Window#types","content":" "},{"title":"WindowConfiguration​","type":1,"pageTitle":"Window","url":"/osgl-graphics/api/Window#WindowConfiguration","content":"&lt;/&gt; interface WindowConfiguration { sizeX: number-- The width of the OSGL window. The maximum width is 1024. Defaults to 100 sizeY: number-- The height of the OSGL window. The maximum height is 1024. Defaults to 100 } An OSGL window is the representation of the EditableImage instance. A window can be created by importing the OSGL 'window' submodule: local OSGL = require(path.to.osgl) local Window = OSGL.Window ​ -- Creates a Window with a size of 50x50 local myWindow = Window.new(path.to.instance, { sizeX = 50, sizeY = 50 })   "},{"title":"Window​","type":1,"pageTitle":"Window","url":"/osgl-graphics/api/Window#Window","content":"&lt;/&gt; interface Window { editableImage: EditableImage -- The actual EditableImage instance. targetFPS: number-- The FPS OSGL should aim to render at. renderers: {ImageLabel | ImageButton }-- A value used internally to keep track of what the Window is rendering too Render: (self: Window) → Window-- Renders the contents of the buffer Clear: ( self: Window, color: Color ) → Window-- Clears the window with a color Resize: ( self: Window, newWidth: number, newHeight: number ) → Window-- Resizes the window to a new size AddRenderer: ( self: Window, ...ImageLabel | ImageButton ) → Window-- Adds a new renderer instance RemoveRenderer: ( self: Window, ...ImageLabel | ImageButton ) → Window-- Removes a renderer instance Deserialize: ( self: Window, bfr: buffer, width: number, height: number ) → Window-- Safely replaces the current window's buffer with a new buffer by resizing it to the specified width and height, preventing errors during the update GetRelativeMouseToRenderer: ( self: Window, image: ImageLabel | ImageButton ) → ( boolean, number, number )-- Returns the mouse position relative to the renderer } An OSGL window is the representation of the EditableImage instance. A window can be created by importing the OSGL 'window' submodule: local OSGL = require(path.to.osgl) local Window = OSGL.Window ​ -- Creates a window from an existing EditableImage local myWindow = Window.from(path.to.editableImage)  "},{"title":"Properties​","type":1,"pageTitle":"Window","url":"/osgl-graphics/api/Window#properties","content":" "},{"title":"editableImage​","type":1,"pageTitle":"Window","url":"/osgl-graphics/api/Window#editableImage","content":"&lt;/&gt; Window.editableImage: EditableImage  The actual editableImage of the Window  "},{"title":"targetFPS​","type":1,"pageTitle":"Window","url":"/osgl-graphics/api/Window#targetFPS","content":"&lt;/&gt; Window.targetFPS: number The Window's Target FPS. Defaults to 60 window.targetFPS = 5 while task.wait() do window:Render() -- Renders at roughly 5FPS end  "},{"title":"Functions​","type":1,"pageTitle":"Window","url":"/osgl-graphics/api/Window#functions","content":" "},{"title":"Render​","type":1,"pageTitle":"Window","url":"/osgl-graphics/api/Window#Render","content":"&lt;/&gt; Window.Render(self: types.Window) → Window Renders the buffer to the EditableImage local OSGL = require(path.to.osgl) local Window = OSGL.Window -- Creates a new Window local myWindow = Window.new(path.to.parent, { sizeX = 50, sizeY = 50 }) -- Runs every heartbeat while task.wait() do -- *rendering magic* myWindow:Render() end   "},{"title":"WritePixel​","type":1,"pageTitle":"Window","url":"/osgl-graphics/api/Window#WritePixel","content":"&lt;/&gt; Window.WritePixel( self: types.Window, x: number,-- X position y: number,-- Y position color: Color-- The color that will be written at the location ) → Window Writes a color to a certain pixel on a window. The exact same as draw.pixel. local OSGL = require(path.to.osgl) local Window = OSGL.Window local color = OSGL.color -- Creates a new EditableImage local myWindow = Window.new(path.to.parent, { sizeX = 50, sizeY = 50 }) myWindow:WritePixel(0, 0, color.RED):Render()   "},{"title":"Clear​","type":1,"pageTitle":"Window","url":"/osgl-graphics/api/Window#Clear","content":"&lt;/&gt; Window.Clear( self: types.Window, clearColor: Color?-- The color the screen will be cleared with ) → Window Clears the double-buffer with the given color or a transparent color local OSGL = require(path.to.osgl) local Window = OSGL.Window local color = OSGL.color -- Creates a new EditableImage local myWindow = Window.new(path.to.parent, { sizeX = 50, sizeY = 50 }) -- Runs every heartbeat while task.wait() do myWindow:Clear(color.GREEN) myWindow:Render() -- The above could also be chained as the followed: --[[ myWindow:Clear(color.GREEN) :Render() --]] end   "},{"title":"AddRenderer​","type":1,"pageTitle":"Window","url":"/osgl-graphics/api/Window#AddRenderer","content":"&lt;/&gt; Window.AddRenderer( self: types.Window, ...: ...(ImageLabel | ImageButton) -- The Images that will become renderers ) → Window Renders the current window to a set of Images with little-to-no performance impact. local OSGL = require(path.to.osgl) local Window = OSGL.Window local color = OSGL.color -- Creates a new EditableImage local myWindow = Window.new(path.to.parent, { sizeX = 50, sizeY = 50 }) myWindow:AddRenderer(path.to.imageA, path.to.imageB) -- imageA and imageB now both render the Window at the same time   "},{"title":"RemoveRenderer​","type":1,"pageTitle":"Window","url":"/osgl-graphics/api/Window#RemoveRenderer","content":"&lt;/&gt; Window.RemoveRenderer( self: types.Window, ...: ...(ImageLabel | ImageButton) -- The Images that will be removed if rendering the Window ) → Window Removes any renderers from any Images that are rendering the Window local OSGL = require(path.to.osgl) local Window = OSGL.Window local color = OSGL.color -- Creates a new EditableImage local myWindow = Window.new(path.to.parent, { sizeX = 50, sizeY = 50 }) myWindow:AddRenderer(path.to.imageA, path.to.imageB) -- imageA and imageB now both render the Window at the same time myWindow:RemoveRenderer(path.to.imageB) -- imageB no longer renders the Window   "},{"title":"Resize​","type":1,"pageTitle":"Window","url":"/osgl-graphics/api/Window#Resize","content":"&lt;/&gt; Window.Resize( self: types.Window, newWidth: number?,-- The new width of the window newHeight: number?-- The new height of the window ) → Window Resizes the window and its pixel buffer. This function may be resource intensive and is not made for constant use. May require a re-render, depending on the new size. After a window is resized, all renderers in window.renderers are added as a renderer local OSGL = require(path.to.osgl) local Window = OSGL.Window local color = OSGL.color -- Creates a new Window local myWindow = Window.new(path.to.parent, { sizeX = 50, sizeY = 50 }) myWindow:Resize(100) -- Changes width to 100 -- Runs every heartbeat while task.wait() do -- *rendering magic* myWindow:Render() end  "},{"title":"Errors","type":1,"pageTitle":"Window","url":"/osgl-graphics/api/Window##","content":"Type\tDescription&quot;Height&quot;\tThis error occurs if the height is smaller than 0 &quot;Width&quot;\tThis error occurs if the width is smaller than 0 &quot;Memory&quot;\tThis error occurs when the device does not have enough memory to resize the window  "},{"title":"Deserialize​","type":1,"pageTitle":"Window","url":"/osgl-graphics/api/Window#Deserialize","content":"&lt;/&gt; Window.Deserialize( bfr: buffer,-- The new buffer width: number?,-- The width of the buffer height: number?-- The height of the buffer ) → Window Safely replaces the current window's buffer with a new buffer by resizing it to the specified width and height, preventing errors during the update -- Save.luau local bfr, width, height = myWindow:Serialize() -- *save data* -- Load.luau local bfr, width, height = -- *load data* window:Deserialize(bfr, width, height)   "},{"title":"GetRelativeMouseToRenderer​","type":1,"pageTitle":"Window","url":"/osgl-graphics/api/Window#GetRelativeMouseToRenderer","content":"&lt;/&gt; Window.GetRelativeMouseToRenderer( self: types.Window, image: ImageLabel | ImageButton -- The renderer instance ) → ( boolean, number, number ) Returns a tuple describing the mouse position relative to the renderer from the top-left corner. The boolean represents if the mouse is in the renderer, and the following 2 numbers are the X and Y local OSGL = require(path.to.osgl) local Window = OSGL.Window local color = OSGL.color -- Creates a new Window local myWindow = Window.new(path.to.parent, { sizeX = 50, sizeY = 50 }) print(myWindow:GetRelativeMouseToRenderer(path.to.parent))   "},{"title":"new​","type":1,"pageTitle":"Window","url":"/osgl-graphics/api/Window#new","content":"&lt;/&gt; Window.new( parent: Instance ,-- The instance the EditableImage will be parented to config: WindowConfiguration?-- Optional configurations ) → Window-- Returns an OSGL window instance Creates an OSGL window by creating a new EditableImage instance at the given place. local OSGL = require(path.to.osgl) local Window = OSGL.Window ​ -- Creates a new Window local myWindow = Window.new(path.to.parent, { size = 50, size = 50 })  "},{"title":"Errors","type":1,"pageTitle":"Window","url":"/osgl-graphics/api/Window##","content":"Type\tDescription&quot;Typechecking&quot;\tThis error occurs when a required argument is not passed or the type is incorrect &quot;Permission&quot;\tThis error occurs when the owner of the place does not have the `EditableImage` feature enabled &quot;Memory&quot;\tThis error occurs when the device doesn't have enough memory to create the Window  "},{"title":"from​","type":1,"pageTitle":"Window","url":"/osgl-graphics/api/Window#from","content":"&lt;/&gt; Window.from( editableImage: EditableImage ,-- The existing EditableImage renderers: {ImageLabel | ImageButton? }-- An argument used internally to initially set any renderers ) → Window-- Returns an OSGL window instance Creates an OSGL window from an existing EditableImage. local OSGL = require(path.to.osgl) local Window = OSGL.Window ​ -- Creates a window from an existing EditableImage local myWindow = Window.from(path.to.editableImage)  "},{"title":"Errors","type":1,"pageTitle":"Window","url":"/osgl-graphics/api/Window##","content":"Type\tDescription&quot;Argument Type&quot;\tThis error occurs when a required argument is not passed or the type is incorrect &quot;Permission&quot;\tThis error occurs when the owner of the place does not have the `EditableImage` feature enabled &quot;Memory&quot;\tThis error occurs when the device doesn't have enough memory to create the Window  "},{"title":"fromAssetId​","type":1,"pageTitle":"Window","url":"/osgl-graphics/api/Window#fromAssetId","content":"&lt;/&gt; Window.fromAssetId( assetId: number-- The assetId that will be loaded ) → Window-- Returns an OSGL window instance Given an assetId, creates a Window. local OSGL = require(path.to.osgl) local Window = OSGL.Window ​ -- Creates a window from an assetId local myWindow = Window.fromAssetId(asset.id) -- use AddRenderers to add a renderer myWindow:AddRenderers(path.to.imageA)  "},{"title":"Errors","type":1,"pageTitle":"Window","url":"/osgl-graphics/api/Window##","content":"Type\tDescription&quot;Permission&quot;\tThis error occurs when the owner of the place does not have the `EditableImage` feature enabled &quot;Memory&quot;\tThis error occurs when the device doesn't have enough memory to create the Window  "},{"title":"fromBuffer​","type":1,"pageTitle":"Window","url":"/osgl-graphics/api/Window#fromBuffer","content":"&lt;/&gt; Window.fromBuffer( bfr: buffer,-- The buffer that will be loaded into the Window config: WindowConfiguration?-- Optional configurations ) → Window-- Returns an OSGL window instance Given a buffer, creates a Window. local OSGL = require(path.to.osgl) local Window = OSGL.Window ​ -- Creates a window from an assetId local myWindow = Window.fromBuffer(bfr, { sizeX = bufferWidth, sizeY = bufferHeight }) -- use AddRenderers to add a renderer myWindow:AddRenderers(path.to.imageA)  "},{"title":"Errors","type":1,"pageTitle":"Window","url":"/osgl-graphics/api/Window##","content":"Type\tDescription&quot;Permission&quot;\tThis error occurs when the owner of the place does not have the `EditableImage` feature enabled &quot;Memory&quot;\tThis error occurs when the device doesn't have enough memory to create the Window "},{"title":"Setting up your environment","type":0,"sectionRef":"#","url":"/osgl-graphics/docs/setting-up-the-env","content":"Setting up your environment If you haven't done so already, download the latest version of OSGL from either the Github releases or from the Roblox Marketplace. Once downloaded, insert it into Studio in a suitible place (such as ReplicatedStorage/Packages) Create an ImageLabel in StarterGui, with its BackgroundTransparency set to 0. This ImageLabel will act as your primary canvas for rendering graphics. note Lower resolutions cause blurred images! If you're rendering at a low resolution, or just want a pixelated look, set the ResampleMode property of your ImageLabel to Pixelated! Additionally, create a LocalScript in your desired location (e.g., StarterPlayer/StarterPlayerScripts ). This script will create our window and manage the rendering process. Now you are ready to begin programming!","keywords":""},{"title":"Migration","type":0,"sectionRef":"#","url":"/osgl-graphics/docs/Migrating/Migration","content":"Migration Welcome to the migration guide for transitioning from CanvasDraw to OSGL. This guide will walk you through the key steps and changes needed to migrate your existing codebase smoothly from CanvasDraw to OSGL. It's important to note that OSGL and CanvasDraw's internal architecture is different. OSGL works completely differently to CanvasDraw, and vice-versa. You may need to refactor your code. In CanvasDraw, you create objects known as canvases, with CanvasDraw.new(). You can replicate this in OSGL by creating a window, which you can read about here: local CanvasDraw = require(path) local OSGL = require(path) local Window = OSGL.Window -- OSGL is broken down into sub-modules that handle different aspects -- CanvasDraw CanvasDraw.new(Parent, Resolution, Color, Blur) -- OSGL Window.new(Parent, { sizeX = width, sizeY = height }) You can utilize the Window.new function to create the equivilent of a CanvasDraw canvas, in OSGL. The OSGL code creates an EditableImage of size: (sizeX, sizeY). All drawing methods can be directly accessed straight from the Canvas object; which is not the case in OSGL. As shown in the code-example above, OSGL is broken down into different sub-modules that each do their own thing (e.g handling color, drawing, loading textures, etc.). Comparison example: local CanvasDraw = require(path) local OSGL = require(path) local Window = OSGL.Window local color = OSGL.color local draw = OSGL.draw -- Draw a red pixel local Canvas = CanvasDraw.new(Frame, Vector2.new(150, 100)) Canvas:DrawPixel(Vector2.new(75, 50), Color3.new(1, 0, 0)) -- Draw a red pixel local window = Window.new(Frame, { sizeX = 150, sizeY = 100 }) draw.pixel(window, 76, 51, color.RED) It's also important to note 2 things: In OSGL, the top-left corner of the window is (0,0). In CanvasDraw, it is (1, 1)The draw module is not needed to draw onto the window Similarly to CanvasDraw, you can draw any shape via method, however OSGL allows you to chain these methods: local Canvas = CanvasDraw.new(Frame, Vector2.new(150, 100)) Canvas:DrawPixel(Vector2.new(75, 50), Color3.new(1, 0, 0)) Canvas:DrawLine(Vector2.new(5, 5), Vector2.new(145, 95), Color3.new(1, 0, 0), 2, true) local window = Window.new(Frame, { sizeX = 150, sizeY = 100 }) window :Draw() -- Opens a &quot;DrawingContext&quot;. :Pixel(76, 51, color.RED) :Line(6, 6, 146, 96, 2, color.RED) :StopDrawing() -- If you want to access the window's methods, you can use this. -- Else, it is not needed! These methods are exactly the same as the Draw methods, but they automatically pass the window as the first argument. You can find more about these methods in the API. Both Windows, and Textures are something known as a DrawableObject. Effectively, a Window is just a special form of a Texture, and by extent, all a Texture is, is a buffer containing pixel-data. This is similar to CanvasDraw's ImageData. If you wanted to save a texture somewhere, all you would have to do is save the buffer, and the sizeX and sizeY (or just the size). Since it's a Texture, you can load it back into the game. This exact process can be described by Serialization and Deserialization: -- Save.luau local bfr, width, height = windowOne:Serialize() -- *save data* -- Load.luau local bfr, width, height = -- *load data* windowTwo:Deserialize(bfr, width, height) You can learn more about this on the designated page linked above. danger The Deserialize function safely scales the size of the buffer. Directly setting the buffer to another buffer may cause size errors! It's always safer to use Deserialize, however if you are confident that both buffers will always be the same size, you can directly set the buffer via: A.buffer = B.buffer ","keywords":""},{"title":"Draw","type":0,"sectionRef":"#","url":"/osgl-graphics/api/Draw","content":"","keywords":""},{"title":"Functions​","type":1,"pageTitle":"Draw","url":"/osgl-graphics/api/Draw#functions","content":" "},{"title":"pixel​","type":1,"pageTitle":"Draw","url":"/osgl-graphics/api/Draw#pixel","content":"&lt;/&gt; Draw.pixel( object: DrawableObject, X: number, Y: number, color: Color ) → () Draws a singular pixel onto the DrawableObject local OSGL = require(path.to.osgl) local Window = OSGL.Window local color = OSGL.color local draw = OSGL.draw -- Creates a new EditableImage local myWindow = Window.new(path.to.parent, { sizeX = 50, sizeY = 50 }) -- Draws a red pixel at 0, 0 draw.pixel(myWindow, 0, 0, color.RED)   "},{"title":"line​","type":1,"pageTitle":"Draw","url":"/osgl-graphics/api/Draw#line","content":"&lt;/&gt; Draw.line( object: DrawableObject, startX: number, startY: number, endX: number, endY: number, thickness: number, color: Color ) → () Draws a line onto the DrawableObject local OSGL = require(path.to.osgl) local Window = OSGL.Window local color = OSGL.color local draw = OSGL.draw -- Creates a new EditableImage local myWindow = Window.new(path.to.parent, { sizeX = 50, sizeY = 50 }) -- Draws a red line from 5, 5 to 10, 10 with a thickness of 2 draw.line(myWindow, 5, 5, 10, 10, 2, color.RED)   "},{"title":"rectangle​","type":1,"pageTitle":"Draw","url":"/osgl-graphics/api/Draw#rectangle","content":"&lt;/&gt; Draw.rectangle( object: DrawableObject, xPos: number, yPos: number, width: number, height: number, fill: Color?, stroke: Color?, strokeThickness: number?, rotation: number? ) → () Draws a rectangle onto the DrawableObject local OSGL = require(path.to.osgl) local Window = OSGL.Window local color = OSGL.color local draw = OSGL.draw -- Creates a new EditableImage local myWindow = Window.new(path.to.parent, { sizeX = 50, sizeY = 50 }) -- Draws a 5x5 red square at 0, 0 draw.rectangle(myWindow, 0, 0, 5, 5, color.RED)   "},{"title":"circle​","type":1,"pageTitle":"Draw","url":"/osgl-graphics/api/Draw#circle","content":"&lt;/&gt; Draw.circle( object: DrawableObject, centerX: number, centerY: number, radius: number, fill: Color?, stroke: Color?, strokeThickness: number?, rotation: number?-- This can only be viewed at low resolutions ) → () Draws a circle onto the DrawableObject local OSGL = require(path.to.osgl) local Window = OSGL.Window local color = OSGL.color local draw = OSGL.draw -- Creates a new EditableImage local myWindow = Window.new(path.to.parent, { sizeX = 50, sizeY = 50 }) -- Draws a red circle with a radius of 10 at 26, 26 draw.circle(myWindow, 26, 26, 10, color.RED)   "},{"title":"triangle​","type":1,"pageTitle":"Draw","url":"/osgl-graphics/api/Draw#triangle","content":"&lt;/&gt; Draw.triangle( object: DrawableObject, x1: number, y1: number, x2: number, y2: number, x3: number, y3: number, fill: Color?, stroke: Color?, strokeThickness: number? ) → () Draws a triangle onto the DrawableObject local OSGL = require(path.to.osgl) local Window = OSGL.Window local color = OSGL.color local draw = OSGL.draw -- Creates a new EditableImage local myWindow = Window.new(path.to.parent, { sizeX = 50, sizeY = 50 }) -- Draws a red triangle with the given points draw.triangle(myWindow, 0, 0, 5, 5, 10, 0, color.RED)   "},{"title":"polygon​","type":1,"pageTitle":"Draw","url":"/osgl-graphics/api/Draw#polygon","content":"&lt;/&gt; Draw.polygon( object: DrawableObject, points: {{number}}, fill: Color? ) → () Draws a polygon onto the DrawableObject local OSGL = require(path.to.osgl) local Window = OSGL.Window local color = OSGL.color local draw = OSGL.draw -- Creates a new EditableImage local myWindow = Window.new(path.to.parent, { sizeX = 50, sizeY = 50 }) -- Draws a red polygon with the given points draw.polygon(myWindow, { -- Points for a triangle { 0, 0 }, { 5, 5 }, { 10,0 }, }, color.RED)   "},{"title":"floodFill​","type":1,"pageTitle":"Draw","url":"/osgl-graphics/api/Draw#floodFill","content":"&lt;/&gt; Draw.floodFill( x: number, y: number, fill: Color ) → () Replaces all adjacent pixels of the same color with a replacement local OSGL = require(path.to.osgl) local Window = OSGL.Window local color = OSGL.color local draw = OSGL.draw -- Creates a new EditableImage local myWindow = Window.new(path.to.parent, { sizeX = 50, sizeY = 50 }) -- *draw something* -- Start flood-filling from (5, 5) myWindow:Draw():FloodFill(5, 5, color.RED)  "},{"title":"Color","type":0,"sectionRef":"#","url":"/osgl-graphics/api/Color","content":"","keywords":""},{"title":"Types​","type":1,"pageTitle":"Color","url":"/osgl-graphics/api/Color#types","content":" "},{"title":"Color​","type":1,"pageTitle":"Color","url":"/osgl-graphics/api/Color#Color","content":"&lt;/&gt; type Color = number local OSGL = require(path.to.osgl) local color = OSGL.color ​ -- All other parameters are defaulted -- to 0, except for alpha, which is -- defaulted to 255. local myAwesomeRedColor = color.new(255)  "},{"title":"Properties​","type":1,"pageTitle":"Color","url":"/osgl-graphics/api/Color#properties","content":" "},{"title":"RED​","type":1,"pageTitle":"Color","url":"/osgl-graphics/api/Color#RED","content":"&lt;/&gt; Color.RED: Color A red color  "},{"title":"GREEN​","type":1,"pageTitle":"Color","url":"/osgl-graphics/api/Color#GREEN","content":"&lt;/&gt; Color.GREEN: Color A green color  "},{"title":"BLUE​","type":1,"pageTitle":"Color","url":"/osgl-graphics/api/Color#BLUE","content":"&lt;/&gt; Color.BLUE: Color A blue color  "},{"title":"WHITE​","type":1,"pageTitle":"Color","url":"/osgl-graphics/api/Color#WHITE","content":"&lt;/&gt; Color.WHITE: Color A white color  "},{"title":"BLACK​","type":1,"pageTitle":"Color","url":"/osgl-graphics/api/Color#BLACK","content":"&lt;/&gt; Color.BLACK: Color A black color  "},{"title":"YELLOW​","type":1,"pageTitle":"Color","url":"/osgl-graphics/api/Color#YELLOW","content":"&lt;/&gt; Color.YELLOW: Color A yellow color  "},{"title":"MAGENTA​","type":1,"pageTitle":"Color","url":"/osgl-graphics/api/Color#MAGENTA","content":"&lt;/&gt; Color.MAGENTA: Color A magenta color  "},{"title":"CYAN​","type":1,"pageTitle":"Color","url":"/osgl-graphics/api/Color#CYAN","content":"&lt;/&gt; Color.CYAN: Color A cyan color  "},{"title":"TRANSPARENT​","type":1,"pageTitle":"Color","url":"/osgl-graphics/api/Color#TRANSPARENT","content":"&lt;/&gt; Color.TRANSPARENT: Color A completely transparent color "},{"title":"Functions​","type":1,"pageTitle":"Color","url":"/osgl-graphics/api/Color#functions","content":" "},{"title":"new​","type":1,"pageTitle":"Color","url":"/osgl-graphics/api/Color#new","content":"&lt;/&gt; Color.new( r: number?, g: number?, b: number?, a: number? ) → Color-- Returns a color Value Creates a new color value. Values cannot be changed manually and must be changed via a function. local OSGL = require(path.to.osgl) local color = OSGL.color -- All other parameters are defaulted -- to 0, except for alpha, which is -- defaulted to 255. local myAwesomeRedColor = color.new(255)   "},{"title":"newRGB​","type":1,"pageTitle":"Color","url":"/osgl-graphics/api/Color#newRGB","content":"&lt;/&gt; Color.newRGB( r: number?, g: number?, b: number? ) → Color-- Returns a color Value Creates a new color value with the alpha channel being 255. Values cannot be changed manually and must be changed via a function. local OSGL = require(path.to.osgl) local color = OSGL.color -- All other parameters are defaulted -- to 0. local myAwesomeRedColor = color.newRGB(255)   "},{"title":"setR​","type":1,"pageTitle":"Color","url":"/osgl-graphics/api/Color#setR","content":"&lt;/&gt; Color.setR( c: Color,-- The color to edit r: number-- The new value ) → number Sets the 'r' channel of the color. local OSGL = require(path.to.osgl) local color = OSGL.color local c = color.setR(color.RED, 100) print(color.r(c)) -- Ouput: 100 For performance boost, if you're creating colors using only 1 or 2 channels, you should do: local almostRed = color.setR(color.BLACK, 100)   "},{"title":"setG​","type":1,"pageTitle":"Color","url":"/osgl-graphics/api/Color#setG","content":"&lt;/&gt; Color.setG( c: Color,-- The color to edit g: number-- The new value ) → number Sets the 'g' channel of the color. local OSGL = require(path.to.osgl) local color = OSGL.color local c = color.setG(color.GREEN, 100) print(color.g(c)) -- Ouput: 100 For performance boost, if you're creating colors using only 1 or 2 channels, you should do: local almostGreen = color.setG(color.BLACK, 100)   "},{"title":"setB​","type":1,"pageTitle":"Color","url":"/osgl-graphics/api/Color#setB","content":"&lt;/&gt; Color.setB( c: Color,-- The color to edit b: number-- The new value ) → number Sets the 'b' channel of the color. local OSGL = require(path.to.osgl) local color = OSGL.color local c = color.setB(color.BLUE, 100) print(color.b(c)) -- Ouput: 100 For performance boost, if you're creating colors using only 1 or 2 channels, you should do: local almostBlue = color.setB(color.BLACK, 100)   "},{"title":"setA​","type":1,"pageTitle":"Color","url":"/osgl-graphics/api/Color#setA","content":"&lt;/&gt; Color.setA( c: Color,-- The color to edit a: number-- The new value ) → number Sets the 'a' channel of the color. local OSGL = require(path.to.osgl) local color = OSGL.color local c = color.setA(color.TRANSPARENT, 100) print(color.a(c)) -- Ouput: 100 For performance boost, if you're creating colors using only 1 or 2 channels, you should do: local almostBlack = color.setA(color.TRANSPARENT, 100)   "},{"title":"read​","type":1,"pageTitle":"Color","url":"/osgl-graphics/api/Color#read","content":"&lt;/&gt; Color.read( rgbaColor: Color-- The color to read ) → {number} Reads the value of the color local OSGL = require(path.to.osgl) local color = OSGL.color -- All other parameters are defaulted to 0, except for alpha, -- which is defaulted to 255. local myAwesomeRedColor = color.new(255) print(color.read(myAwesomeRedColor)) -- Output: { 255, 0, 0, 255 }   "},{"title":"r​","type":1,"pageTitle":"Color","url":"/osgl-graphics/api/Color#r","content":"&lt;/&gt; Color.r( color: Color-- The color to read ) → number Reads the 'r' value of the color local OSGL = require(path.to.osgl) local color = OSGL.color -- All other parameters are defaulted to 0, except for alpha, -- which is defaulted to 255. local myAwesomeRedColor = color.new(255) print color.r(myAwesomeRedColor)) -- Ouput: 255   "},{"title":"g​","type":1,"pageTitle":"Color","url":"/osgl-graphics/api/Color#g","content":"&lt;/&gt; Color.g( color: Color-- The color to read ) → number Reads the 'g' value of the color local OSGL = require(path.to.osgl) local color = OSGL.color -- All other parameters are defaulted to 0, except for alpha, -- which is defaulted to 255. local myAwesomeRedColor = color.new(255) print color.g(myAwesomeRedColor)) -- Ouput: 0   "},{"title":"b​","type":1,"pageTitle":"Color","url":"/osgl-graphics/api/Color#b","content":"&lt;/&gt; Color.b( color: Color-- The color to read ) → number Reads the 'b' value of the color local OSGL = require(path.to.osgl) local color = OSGL.color -- All other parameters are defaulted to 0, except for alpha, -- which is defaulted to 255. local myAwesomeRedColor = color.new(255) print color.b(myAwesomeRedColor)) -- Ouput: 0   "},{"title":"a​","type":1,"pageTitle":"Color","url":"/osgl-graphics/api/Color#a","content":"&lt;/&gt; Color.a( color: Color-- The color to read ) → number Reads the 'a' value of the color local OSGL = require(path.to.osgl) local color = OSGL.color -- All other parameters are defaulted to 0, except for alpha, -- which is defaulted to 255. local myAwesomeRedColor = color.new(255) print(color.a(myAwesomeRedColor)) -- Ouput: 255   "},{"title":"tint​","type":1,"pageTitle":"Color","url":"/osgl-graphics/api/Color#tint","content":"&lt;/&gt; Color.tint( color1: Color,-- The color to tint color2: Color,-- The tint that will be applied factor: number-- How strong the tint is ) → number Tints the color towards the other color using a tint factor. A tint factor of 0 means color1 will be returned, while a tint factor of 1 means color2 will be returned. local OSGL = require(path.to.osgl) local color = OSGL.color local whiteTintedRed = color.tint(color.WHITE, color.RED, 0.5)  "}]