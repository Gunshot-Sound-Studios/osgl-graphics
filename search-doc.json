[{"title":"Introduction","type":0,"sectionRef":"#","url":"/osgl-graphics/docs/intro","content":"Introduction Welcome to the official documentation for OSGL (Open-Source Graphical Library)! OSGL is an open-source framework designed to provide developers with an efficient way to manipulate and render pixel data using EditableImages. Please note that OSGL is currently in a &quot;beta&quot; phase. While many features are planned, they are yet to be implemented. Your feedback and contributions are invaluable as we continue to enhance the library! What This Documentation Covers In this guide, you'll learn how to: Open a window using OSGL.Draw pixels, shapes, and other graphical elements such as sprites to the window. This documentation assumes you have a basic understand of Luau. If you're new, you can find plenty of resources online!","keywords":""},{"title":"Setting up our environment","type":0,"sectionRef":"#","url":"/osgl-graphics/docs/setting-up-the-env","content":"Setting up our environment Before we can use OSGL, there are a few things we need to do first. Firstly, we need to make sure that we have the EditableImage beta option enabled in Studio. You can enable it in File &gt; Beta Features &gt; EditableImages &amp; EditableMeshes If you haven't already, grab yourself the latest copy of OSGL from the github or the Roblox marketplace, and insert it into Studio in a suitible place (such as ReplicatedStorage/Packages) Create an ImageLabel in StarterGui, with its BackgroundTransparency set to 0. This ImageLabel will serve as your canvas: note Lower resolutions cause blurred images! If you're rendering at a low resolution, set the ResampleMode property of your ImageLabel to Pixelated! Additionally, create a LocalScript in your desired location (e.g., StarterPlayer/StarterPlayerScripts ) and name it appropriately. This script will create our window and manage the rendering process. Now we can start programming!","keywords":""},{"title":"Custom OSGL Image-Format","type":0,"sectionRef":"#","url":"/osgl-graphics/docs/Sprites/custom-texture-format","content":"Custom OSGL Image-Format info This is something that OSGL uses internally! It does not relate to drawing anything on the screen. If you're still interested in the file-structure, you can continue reading. An OSGL texture (known as a FlagTexture internally) is the texture generated by the converter exe. The texture, which is a dictionary, has 3 keys: width (The width of the texture)height (The height of the texture) pixels (The raw pixel data of the texture) The pixels key of the texture is of type { number | string }. The number being of type color, and the string meaning a repeated pixel. The color is self-explanatory. It is the color of a specific pixel at a specific location. A string however contains multiple pixels of the same color, in the format: &quot;rX-Y&quot;, X meaning how many times that pixel is repeated, and Y being the actual pixel itself. For example, 5 pixels in a row of color &quot;0&quot; would be stored as &quot;r5-0&quot;. Colors Colors are stored as a single 32-bit unsigned integer (u32). This allows for compact representation and fast manipulation of colors in the form of a single number. Each 32-bit color value is structured as four 8-bit components, representing the Red, Green, Blue, and Alpha (opacity) channels of the color. These components are packed into the 32-bit integer, with each component occupying one byte (8 bits). Byte Layout of the Color The four components are stored in the following order, from the most significant byte to the least significant byte: First byte (bits 24-31): Red (R) Second byte (bits 16-23): Green (G) Third byte (bits 8-15): Blue (B) Fourth byte (bits 0-7): Alpha (A) This can be visualised as: R\tG\tB\tA8 bits\t8 bits\t8 bits\t8 bits 24-31\t16-23\t8-15\t0-7 For example, consider the color with the following components: Red (R): 255 (0xFF) Green (G): 128 (0x80) Blue (B): 64 (0x40) Alpha (A): 255 (0xFF) These components would be packed into a 32-bit integer as follows: Red (R): 255 (0xFF) -&gt; Occupies bits 24-31 Green (G): 128 (0x80) -&gt; Occupies bits 16-23 Blue (B): 64 (0x40) -&gt; Occupies bits 8-15 Alpha (A): 255 (0xFF) -&gt; Occupies bits 0-7 The resulting 32-bit integer representation would be: 0xFF8040FF (4286595327)","keywords":""},{"title":"Drawing Shapes","type":0,"sectionRef":"#","url":"/osgl-graphics/docs/Shapes/drawing-shapes","content":"Drawing Shapes Below is a list of shapes in OSGL as of version 1.2b: Shape\tSupported\tSupports Rotation\tSupports Stroke\tNotesPixel\t✅\tN/A\tN/A Rectangle\t✅\t✅\t✅ Circle\t✅\t✅\t✅\tRotation is only visible at low resolutions. Lines\t✅\tN/A\t❌ Points\t✅\tN/A\t❌ Triangle\t❌\tN/A\tN/A\tWill be implemented All shape-drawing functions can be accessed through the draw sub-module of OSGL. The first argument for each function is a Drawable object, which could be a Window or Texture. You'll also need to provide the relevant properties to define the shape (e.g., position, size, color). Here's an example of drawing a rectangle: draw.rectangle(window, { xPos = 0, yPos = 0, width = 5, height = 5, fillColor = color.RED, -- Rotation defaults to 0. -- Strokes are completely optional strokeColor = color.BLACK, strokeThickness = 2 }) Notes: Rotation: Most shapes support rotation, but in some cases (e.g., circles), the rotation is only visible at low resolutions. Stroke: For shapes that support strokes, you can define both the stroke color and thickness. However, strokes are entirely optional and can be omitted if not needed.","keywords":""},{"title":"Planned updates","type":0,"sectionRef":"#","url":"/osgl-graphics/docs/Whats Next/planned-updates","content":"Planned updates Below is a list of possible upcoming OSGL features: Shapes: Triangles Fonts &amp; Texts","keywords":""},{"title":"Sprite","type":0,"sectionRef":"#","url":"/osgl-graphics/api/Sprite","content":"","keywords":""},{"title":"Types​","type":1,"pageTitle":"Sprite","url":"/osgl-graphics/api/Sprite#types","content":" "},{"title":"Sprite​","type":1,"pageTitle":"Sprite","url":"/osgl-graphics/api/Sprite#Sprite","content":"&lt;/&gt; interface Sprite { texture: Texture-- The sprites' texture color: Color-- The color of the sprite x: number-- The X position of the sprite y: number-- The Y position of the sprite } A Sprite can be drawn onto onto the screen to display a Texture "},{"title":"Functions​","type":1,"pageTitle":"Sprite","url":"/osgl-graphics/api/Sprite#functions","content":" "},{"title":"new​","type":1,"pageTitle":"Sprite","url":"/osgl-graphics/api/Sprite#new","content":"&lt;/&gt; Sprite.new( Texture: Texture-- The texture of the sprite ) → Sprite-- The new sprite Creates a new sprite local OSGL = require(path.to.osgl) local Sprite = OSGL.Sprite ​ local txt -- *load texture* local mySprite = Sprite.new(txt)   "},{"title":"Draw​","type":1,"pageTitle":"Sprite","url":"/osgl-graphics/api/Sprite#Draw","content":"&lt;/&gt; Sprite:Draw( window: Drawable-- The window, or texture, the sprite will be drawn on. ) → () Creates a new sprite on the given window or texture. local OSGL = require(path.to.osgl) local Window = OSGL.Window local Sprite = OSGL.Sprite ​ -- Creates a window from an existing EditableImage local myWindow = Window.from(path.to.editableImage, { sizeX = 50, sizeY = 50 }) local txt = -- *load texture* local mySprite = Sprite.new(myWindow, txt) mySprite:Draw(myWindow) -- Draws the sprite onto the window at 0, 0  "},{"title":"Opening a window","type":0,"sectionRef":"#","url":"/osgl-graphics/docs/Windows/opening-a-window","content":"Opening a window In OSGL, a &quot;window&quot; is actually just a fancy name for an EditableImage. All that OSGL does, is wrap this EditableImage in an easy-to-use API for you. Before we can actually draw on our window, we need to create one. OSGL is split into sub-modules that each serve a different purpose (e.g, drawing on a window, creating a window). In this case, we want the Window class which allows us to create our window. local OSGL = require(ReplicatedStorage.Packages.OSGL) local Window = OSGL.Window There are two functions available for creating our window: Window.from and Window.new . According to the API: Window.from : Creates an OSGL window from an existing EditableImage. Window.new : Creates an OSGL window by initializing a new EditableImage instance at the specified location. Since we don’t have an existing EditableImage , we'll use Window.new to create our window on the designated ImageLabel : local OSGL = require(ReplicatedStorage.Packages.OSGL) local Window = OSGL.Window local windowUi = -- *reference to windowUi, our `ImageLabel`* -- Create our window, 500x500 local myWindow = Window.new(windowUi, { sizeX = 500, sizeY = 500 }) The example above creates an OSGL window, with a size of 500x500, on windowUi. You can find more details about this function in the API And that's it! We have our OSGL window ready and setup for rendering!","keywords":""},{"title":"Draw","type":0,"sectionRef":"#","url":"/osgl-graphics/api/Draw","content":"","keywords":""},{"title":"Types​","type":1,"pageTitle":"Draw","url":"/osgl-graphics/api/Draw#types","content":" "},{"title":"Points​","type":1,"pageTitle":"Draw","url":"/osgl-graphics/api/Draw#Points","content":"&lt;/&gt; type Points = {{number}} An array of points  "},{"title":"Drawable​","type":1,"pageTitle":"Draw","url":"/osgl-graphics/api/Draw#Drawable","content":"&lt;/&gt; type Drawable = Window | Texture An object that contains a buffer. You can draw to these objects. "},{"title":"Functions​","type":1,"pageTitle":"Draw","url":"/osgl-graphics/api/Draw#functions","content":" "},{"title":"pixel​","type":1,"pageTitle":"Draw","url":"/osgl-graphics/api/Draw#pixel","content":"&lt;/&gt; Draw.pixel( window: Drawable,-- The window or texture to draw on xPos: number,-- The X-Position of the pixel, yPos: number,-- The Y-Position of the pixel color: Color-- The color of the pixel ) → nil Draws a singular pixel at the given location local OSGL = require(path.to.osgl) local draw = OSGL.draw local Window = OSGL.Window local color = OSGL.color -- Creates a new EditableImage local myWindow = Window.new(path.to.parent, { sizeX = 50, sizeY = 50 }) -- Runs every heartbeat while myWindow:IsOpen() do -- Render here -- Draws a pixel at 0, 0, with a red color, onto &quot;myWindow&quot; draw.pixel(myWindow, 0, 0, color.RED) -- Stop rendering here myWindow:Render() end print(&quot;The window has been destroyed.&quot;)  "},{"title":"Errors","type":1,"pageTitle":"Draw","url":"/osgl-graphics/api/Draw##","content":"Type\tDescription&quot;X&quot;\tThis error occurs if the X is less than 0 &quot;Y&quot;\tThis error occurs if the Y is less than 0  "},{"title":"line​","type":1,"pageTitle":"Draw","url":"/osgl-graphics/api/Draw#line","content":"&lt;/&gt; Draw.line( window: Drawable,-- The window or texture to draw on line: { startX: number, startY: number, stopX: number, stopY: number, thickness: number, color: Color? }-- The data that is used to construct the line ) → nil Draws a line from point A to point B local OSGL = require(path.to.osgl) local draw = OSGL.draw local Window = OSGL.Window local color = OSGL.color -- Creates a new EditableImage local myWindow = Window.new(path.to.parent, { sizeX = 50, sizeY = 50 }) -- Runs every heartbeat while myWindow:IsOpen() do -- Render here -- Draws a red line from 0,0 to 29,29 draw.line(myWindow, { startX = 0, startY = 0, stopX = 29, stopY = 29, -- Thickness defaults to 1 -- Color defaults to black color = color.RED }) -- Stop rendering here myWindow:Render() end print(&quot;The window has been destroyed.&quot;)   "},{"title":"circle​","type":1,"pageTitle":"Draw","url":"/osgl-graphics/api/Draw#circle","content":"&lt;/&gt; Draw.circle( window: Drawable,-- The window or texture to draw on circle: { centerX: number, centerY: number, radius: number, fillColor: Color?, strokeColor: Color?, strokeThickness: number?, rotation: number? }-- The data that is used to construct the circle ) → nil Draws a circle with an optional stroke onto the screen local OSGL = require(path.to.osgl) local Draw = OSGL.draw local Window = OSGL.Window local color = OSGL.color -- Creates a new EditableImage local myWindow = Window.new(path.to.parent, { sizeX = 50, sizeY = 50 }) -- Runs every heartbeat while myWindow:IsOpen() do -- Render here -- Draw our circle myWindow:Clear(color.TRANSPARENT) draw.circle(myWindow, { centerX = 25, centerY = 25, radius = 10, fillColor = color.RED, -- Rotation defaults to 0. -- Strokes are completely optional strokeColor = color.BLACK, strokeThickness = 2 }) -- Stop rendering here myWindow:Render() end print(&quot;The window has been destroyed.&quot;)   "},{"title":"rectangle​","type":1,"pageTitle":"Draw","url":"/osgl-graphics/api/Draw#rectangle","content":"&lt;/&gt; Draw.rectangle( window: Drawable,-- The window or texture to draw on rectangle: { xPos: number, yPos: number, width: number, height: number, fillColor: Color?, strokeColor: Color?, strokeThickness: number?, rotation: number? }-- The data that is used to construct the rectangle ) → nil Draws a rectangle with an optional stroke on the screen local OSGL = require(path.to.osgl) local draw = OSGL.draw local Window = OSGL.Window local color = OSGL.color -- Creates a new EditableImage local myWindow = Window.new(path.to.parent, { sizeX = 50, sizeY = 50 }) -- Runs every heartbeat while myWindow:IsOpen() do -- Render here -- Draws a square (5x5) at 0, 0, with a red color, onto &quot;myWindow&quot; draw.rectangle(myWindow, { xPos = 0, yPos = 0, width = 5, height = 5, fillColor = color.RED, -- Rotation defaults to 0. -- Strokes are completely optional strokeColor = color.BLACK, strokeThickness = 2 }) -- Stop rendering here myWindow:Render() end print(&quot;The window has been destroyed.&quot;)   "},{"title":"points​","type":1,"pageTitle":"Draw","url":"/osgl-graphics/api/Draw#points","content":"&lt;/&gt; Draw.points( window: Drawable,-- The window or texture to draw on points: { x: number, y: number, points: Points, fillColor: Color }-- The data which is used to construct the shape ) → nil Draws a shape from the given points local OSGL = require(path.to.osgl) local draw = OSGL.draw local Window = OSGL.Window local color = OSGL.color -- Creates a new EditableImage local myWindow = Window.new(path.to.parent, { sizeX = 50, sizeY = 50 }) -- An array of points (x, y) local points = { { 0, 0 }, { 6, 0 }, { 6, 6 }, { 0, 6 }, } -- Runs every heartbeat while myWindow:IsOpen() do -- Render here -- Draws a square at 0, 0, with a red color, onto &quot;myWindow&quot; draw.points(myWindow, { points = points, color = color.RED, x = 0, y = 0, }) -- Stop rendering here myWindow:Render() end print(&quot;The window has been destroyed.&quot;)  "},{"title":"Errors","type":1,"pageTitle":"Draw","url":"/osgl-graphics/api/Draw##","content":"Type\tDescription&quot;X&quot;\tThis error occurs if the X is smaller than 0 &quot;Y&quot;\tThis error occurs if the Y is smaller than 0 &quot;Points&quot;\tThis error occurs if 2 or less points are provided "},{"title":"Managing & Rendering to a window","type":0,"sectionRef":"#","url":"/osgl-graphics/docs/Windows/managing-and-rendering-to-a-window","content":"Managing &amp; Rendering to a window Now that we have our window, let's make this code a bit more interesting. local OSGL = require(ReplicatedStorage.Packages.OSGL) local Window = OSGL.Window local color = OSGL.color local windowUi = -- *reference to windowUi, our `ImageLabel`* -- Create our window, 500x500 local myWindow = Window.new(windowUi, { sizeX = 500, sizeY = 500 }) while myWindow:IsOpen() do myWindow:Clear(color.BLACK) myWindow:Render() end In summary, the above code creates a window, and while it is open, clears the screen with a BLACK color (0, 0, 0, 255). The IsOpen method returns if our window still exists, yielding for a heartbeat, meaning we don't need to include a task.wait. The Clear method clears the Windows' buffer with the given color, which in this case is BLACK. Finally, we call the Render method, which, as the name suggests, renders the buffer to the screen. After the window is destroyed, the program will end. The color sub-module is used to manipulate OSGL colors (RGBA). Using IsOpen is known as the &quot;event loop&quot; or the &quot;game loop&quot;. The contents of this loop are usually executed every frame. But what else can we do other than clear the buffer? We can utilize the draw sub-module to draw directly to the buffer. All drawing functions require a Window or Texture to draw too. For example, to draw a pixel: local OSGL = require(ReplicatedStorage.Packages.OSGL) local Window = OSGL.Window local color = OSGL.color local windowUi = -- *reference to windowUi, our `ImageLabel`* -- Create our window, 10x10 local myWindow = Window.new(windowUi, { sizeX = 10, sizeY = 10 }) while myWindow:IsOpen() do myWindow:Clear(color.BLACK) -- It isn't necessary to clear the screen. If you want to keep the contents -- of the previous frame, you can! -- Draw a red pixel on `myWindow`, at 0, 0 draw.pixel(myWindow, 0, 0, color.RED) myWindow:Render() end You can learn more about the different shapes you can draw in &quot;Drawing shapes&quot;!","keywords":""},{"title":"Texture","type":0,"sectionRef":"#","url":"/osgl-graphics/api/Texture","content":"","keywords":""},{"title":"Types​","type":1,"pageTitle":"Texture","url":"/osgl-graphics/api/Texture#types","content":" "},{"title":"FlagTexture​","type":1,"pageTitle":"Texture","url":"/osgl-graphics/api/Texture#FlagTexture","content":"&lt;/&gt; type FlagTexture = { width: number, height: number, pixels: {Color | string}, } The representation of a texture made with the converter exe provided with the module.  "},{"title":"RawTexture​","type":1,"pageTitle":"Texture","url":"/osgl-graphics/api/Texture#RawTexture","content":"&lt;/&gt; type RawTexture = {Color} The colors of a texture's pixels.  "},{"title":"Texture​","type":1,"pageTitle":"Texture","url":"/osgl-graphics/api/Texture#Texture","content":"&lt;/&gt; interface Texture { pixels: RawTexture-- The raw-bytes of the texture sizeX: number-- The width of the texture sizeY: number-- The height of the texture } A Texture can be drawn onto a Sprite to be displayed on-screen. Textures are simply an array of colors. "},{"title":"Functions​","type":1,"pageTitle":"Texture","url":"/osgl-graphics/api/Texture#functions","content":" "},{"title":"from​","type":1,"pageTitle":"Texture","url":"/osgl-graphics/api/Texture#from","content":"&lt;/&gt; Texture.from( textureData: FlagTexture | ModuleScript -- The string that was generated by the converter exe ) → types.Texture Loads a texture from a string, or a module that returns a string. local OSGL = require(path.to.osgl) local Window = OSGL.Window local texture = OSGL.texture ​ -- Creates a window from an existing EditableImage local myWindow = Window.from(path.to.editableImage, { sizeX = 50, sizeY = 50 }) local txt = texture.from(script.ModuleThatReturnsTexture)   "},{"title":"new​","type":1,"pageTitle":"Texture","url":"/osgl-graphics/api/Texture#new","content":"&lt;/&gt; Texture.new( sizeX: number,-- The width of the texture sizeY: number-- The height of the texture ) → Texture-- The final texture Creates a texture of the given width and height local OSGL = require(path.to.osgl) local Window = OSGL.Window local texture = OSGL.texture ​ -- Creates a window from an existing EditableImage local myWindow = Window.from(path.to.editableImage, { sizeX = 50, sizeY = 50 }) local txt = texture.new(50, 50)   "},{"title":"read​","type":1,"pageTitle":"Texture","url":"/osgl-graphics/api/Texture#read","content":"&lt;/&gt; Texture.read( window: Drawable,-- The drawable-object that will be read x: number,-- The X position of the area that will be read y: number,-- The position of the area that will be read xSize: number?,-- The X-Size of the chunk. Defaults to 1 ySize: number?-- The Y-Size of the chunk. Defaults to 1 ) → {types.Color}-- The colors in the specified chunk Reads the desired chunk from a drawable object local OSGL = require(path.to.osgl) local Window = OSGL.Window local texture = OSGL.texture ​ -- Creates a window from an existing EditableImage local myWindow = Window.from(path.to.editableImage, { sizeX = 50, sizeY = 50 }) -- *Draw somthing here* -- Read a 5x5 square chunk, with the top-left corner -- being at 0, 0. This will return an array of colors -- of length 25 (assuming the window isn't smaller than 5x5 pixels) print(texture.read(myWindow, 0, 0, 5, 5))  "},{"title":"Errors","type":1,"pageTitle":"Texture","url":"/osgl-graphics/api/Texture##","content":"Type\tDescription&quot;X&quot;\tThis error occurs if the X is less than 0 &quot;Y&quot;\tThis error occurs if the Y is less than 0 &quot;XSize&quot;\tThis error occurs if the XSize is less than 1 &quot;YSize&quot;\tThis error occurs if the YSize is less than 1 "},{"title":"Window","type":0,"sectionRef":"#","url":"/osgl-graphics/api/Window","content":"","keywords":""},{"title":"Types​","type":1,"pageTitle":"Window","url":"/osgl-graphics/api/Window#types","content":" "},{"title":"Window​","type":1,"pageTitle":"Window","url":"/osgl-graphics/api/Window#Window","content":"&lt;/&gt; interface Window { renderer: EditableImage -- The actual EditableImage instance. pixels: {Color}-- An array of color values. } An OSGL window is the representation of the EditableImage instance. A window can be created by importing the OSGL 'window' submodule: local OSGL = require(path.to.osgl) local Window = OSGL.Window ​ -- Creates a window from an existing EditableImage local myWindow = Window.from(path.to.editableImage)   "},{"title":"WindowConfiguration​","type":1,"pageTitle":"Window","url":"/osgl-graphics/api/Window#WindowConfiguration","content":"&lt;/&gt; interface WindowConfiguration { sizeX: number-- The width of the OSGL window. The maximum width is 1024. Defaults to 100 sizeY: number-- The height of the OSGL window. The maximum height is 1024. Defaults to 100 } An OSGL window is the representation of the EditableImage instance. A window can be created by importing the OSGL 'window' submodule: local OSGL = require(path.to.osgl) local Window = OSGL.Window ​ -- Creates a Window with a size of 50x50 local myWindow = Window.new(path.to.instance, { sizeX = 50, sizeY = 50 })  "},{"title":"Functions​","type":1,"pageTitle":"Window","url":"/osgl-graphics/api/Window#functions","content":" "},{"title":"new​","type":1,"pageTitle":"Window","url":"/osgl-graphics/api/Window#new","content":"&lt;/&gt; Window.new( parent: Instance ,-- The instance the EditableImage will be parented to config: WindowConfiguration?-- Optional configurations ) → Window-- Returns an OSGL window instance Creates an OSGL window by creating a new EditableImage instance at the given place. local OSGL = require(path.to.osgl) local Window = OSGL.Window ​ -- Creates a new Window local myWindow = Window.new(path.to.parent, { sizeX = 50, sizeY = 50 })  "},{"title":"Errors","type":1,"pageTitle":"Window","url":"/osgl-graphics/api/Window##","content":"Type\tDescription&quot;Argument Type&quot;\tThis error occurs when a required argument is not passed or the type is incorrect  "},{"title":"from​","type":1,"pageTitle":"Window","url":"/osgl-graphics/api/Window#from","content":"&lt;/&gt; Window.from( editableImage: EditableImage -- The existing EditableImage ) → Window-- Returns an OSGL window instance Creates an OSGL window from an existing EditableImage. local OSGL = require(path.to.osgl) local Window = OSGL.Window ​ -- Creates a window from an existing EditableImage local myWindow = Window.from(path.to.editableImage, { size = Vector2.new(50, 50) })  "},{"title":"Errors","type":1,"pageTitle":"Window","url":"/osgl-graphics/api/Window##","content":"Type\tDescription&quot;Argument Type&quot;\tThis error occurs when a required argument is not passed or the type is incorrect  "},{"title":"IsOpen​","type":1,"pageTitle":"Window","url":"/osgl-graphics/api/Window#IsOpen","content":"&lt;/&gt; Window:IsOpen( yield: number?-- The amount of time to yield. Defaults to a heartbeat. ) → boolean Returns if the OSGL Window still exists. Useful for game-loops. Automatically yields for a heartbeat, or the given time. local OSGL = require(path.to.osgl) local Window = OSGL.Window -- Creates a new Window local myWindow = Window.new(path.to.parent, { sizeX = 50, sizeY = 50 }) -- Runs every heartbeat while myWindow:IsOpen() do print(&quot;Window exists!&quot;) end print(&quot;The window has been destroyed.&quot;)  "},{"title":"Errors","type":1,"pageTitle":"Window","url":"/osgl-graphics/api/Window##","content":"Type\tDescription&quot;Argument Type&quot;\tThis error occurs when a required argument is not passed or the type is incorrect  "},{"title":"Render​","type":1,"pageTitle":"Window","url":"/osgl-graphics/api/Window#Render","content":"&lt;/&gt; Window:Render() → () Renders Window.pixels to the EditableImage local OSGL = require(path.to.osgl) local Window = OSGL.Window -- Creates a new Window local myWindow = Window.new(path.to.parent, { sizeX = 50, sizeY = 50 }) -- Runs every heartbeat while myWindow:IsOpen() do -- *rendering magic* myWindow:Render() end   "},{"title":"Clear​","type":1,"pageTitle":"Window","url":"/osgl-graphics/api/Window#Clear","content":"&lt;/&gt; Window:Clear( clearColor: Color?-- The color the screen will be cleared with ) → () Clears the double-buffer with the given color or a transparent color local OSGL = require(path.to.osgl) local Window = OSGL.Window local color = OSGL.color -- Creates a new EditableImage local myWindow = Window.new(path.to.parent, { sizeX = 50, sizeY = 50 }) -- Runs every heartbeat while myWindow:IsOpen() do myWindow:Clear(color.GREEN) myWindow:Render() end   "},{"title":"Resize​","type":1,"pageTitle":"Window","url":"/osgl-graphics/api/Window#Resize","content":"&lt;/&gt; Window:Resize( newWidth: number?,-- The new width of the window newHeight: number?-- The new height of the window ) → () Resizes the window and its pixel buffer. This function may be resource intensive and is not made for constant use. May require a re-render, depending on the new size. local OSGL = require(path.to.osgl) local Window = OSGL.Window local color = OSGL.color -- Creates a new Window local myWindow = Window.new(path.to.parent, { sizeX = 50, sizeY = 50 }) myWindow:Resize(100) -- Changes width to 100 -- Runs every heartbeat while myWindow:IsOpen() do -- *rendering magic* myWindow:Render() end  "},{"title":"Errors","type":1,"pageTitle":"Window","url":"/osgl-graphics/api/Window##","content":"Type\tDescription&quot;Height&quot;\tThis error occurs if the height is smaller than 0 &quot;Width&quot;\tThis error occurs if the width is smaller than 0  "},{"title":"GetRelativeMouse​","type":1,"pageTitle":"Window","url":"/osgl-graphics/api/Window#GetRelativeMouse","content":"&lt;/&gt; Window:GetRelativeMouse() → ( number, number )-- The X and Y of the mouse. Returns the mouse position relative to the window. Useful to know if the mouse is on-top of the window or not. local OSGL = require(path.to.osgl) local Window = OSGL.Window local color = OSGL.color -- Creates a new Window local myWindow = Window.new(path.to.parent, { sizeX = 50, sizeY = 50 }) print(myWindow:GetRelativeMouse()) -- Example output: 25, 25  "},{"title":"Rendering with sprites","type":0,"sectionRef":"#","url":"/osgl-graphics/docs/Sprites/rendering-with-sprites","content":"Rendering with sprites A texture on its own cannot directly be drawn to the screen. Instead, it can be applied to a Sprite, which can render itself on the screen. Creating a sprite is as simple as: local OSGL = require(path.to.osgl) local Sprite = OSGL.Sprite ​ local txt -- *load texture* local mySprite = Sprite.new(txt) You can then render these sprites to a window (or even another texture) by using its Draw method: local OSGL = require(path.to.osgl) local Window = OSGL.Window local Sprite = OSGL.Sprite ​ -- Creates a window from an existing EditableImage local myWindow = Window.from(path.to.editableImage, { sizeX = 50, sizeY = 50 }) local txt = -- *load texture* local mySprite = Sprite.new(myWindow, txt) mySprite:Draw(myWindow) Sprites also have an X and Y, meaning you can change the position of the sprite on the screen.","keywords":""},{"title":"Loading Textures","type":0,"sectionRef":"#","url":"/osgl-graphics/docs/Sprites/loading-textures","content":"Loading Textures To load file formats such as PNGs, and WebPs, OSGL uses its own external tool. The tool bundles with OSGL on the github releases, here, named converter.exe! note You can get help with the converter exe by running it in the command-prompt, with the -h flag! e.g: &gt; converter -h The converter turns these image formats into OSGLs custom image-format, which you can learn more about here. We can load textures into OSGL with the texture.from function, which takes the texture generated by the converter, or a module that returns that: local OSGL = require(path.to.osgl) local texture = OSGL.texture ​ local txt = texture.from(script.ModuleThatReturnsTexture) -- &quot;txt&quot; now contains OSGL-Texture data You can also create a blank texture of the given width, and height, with the texture.new function: local OSGL = require(path.to.osgl) local texture = OSGL.texture ​ local txt = texture.new(50, 50) -- Creates a 50x50 texture info Remember that like windows, textures can also be drawn to! You can edit a texture like any other window by passing it as the first argument of a draw function.","keywords":""},{"title":"Color","type":0,"sectionRef":"#","url":"/osgl-graphics/api/Color","content":"","keywords":""},{"title":"Types​","type":1,"pageTitle":"Color","url":"/osgl-graphics/api/Color#types","content":" "},{"title":"Color​","type":1,"pageTitle":"Color","url":"/osgl-graphics/api/Color#Color","content":"&lt;/&gt; type Color = number local OSGL = require(path.to.osgl) local color = OSGL.color ​ -- All other parameters are defaulted -- to 0, except for alpha, which is -- defaulted to 255. local myAwesomeRedColor = color.new(255)  "},{"title":"Properties​","type":1,"pageTitle":"Color","url":"/osgl-graphics/api/Color#properties","content":" "},{"title":"RED​","type":1,"pageTitle":"Color","url":"/osgl-graphics/api/Color#RED","content":"&lt;/&gt; Color.RED: Color A red color  "},{"title":"GREEN​","type":1,"pageTitle":"Color","url":"/osgl-graphics/api/Color#GREEN","content":"&lt;/&gt; Color.GREEN: Color A green color  "},{"title":"BLUE​","type":1,"pageTitle":"Color","url":"/osgl-graphics/api/Color#BLUE","content":"&lt;/&gt; Color.BLUE: color A blue color  "},{"title":"WHITE​","type":1,"pageTitle":"Color","url":"/osgl-graphics/api/Color#WHITE","content":"&lt;/&gt; Color.WHITE: Color A white color  "},{"title":"BLACK​","type":1,"pageTitle":"Color","url":"/osgl-graphics/api/Color#BLACK","content":"&lt;/&gt; Color.BLACK: Color A black color  "},{"title":"YELLOW​","type":1,"pageTitle":"Color","url":"/osgl-graphics/api/Color#YELLOW","content":"&lt;/&gt; Color.YELLOW: Color A yellow color  "},{"title":"MAGENTA​","type":1,"pageTitle":"Color","url":"/osgl-graphics/api/Color#MAGENTA","content":"&lt;/&gt; Color.MAGENTA: Color A magenta color  "},{"title":"CYAN​","type":1,"pageTitle":"Color","url":"/osgl-graphics/api/Color#CYAN","content":"&lt;/&gt; Color.CYAN: Color A cyan color  "},{"title":"TRANSPARENT​","type":1,"pageTitle":"Color","url":"/osgl-graphics/api/Color#TRANSPARENT","content":"&lt;/&gt; Color.TRANSPARENT: Color A completely transparent color "},{"title":"Functions​","type":1,"pageTitle":"Color","url":"/osgl-graphics/api/Color#functions","content":" "},{"title":"new​","type":1,"pageTitle":"Color","url":"/osgl-graphics/api/Color#new","content":"&lt;/&gt; Color.new( red: number?, green: number?, blue: number?, alpha: number? ) → Color-- Returns a color Value Creates a new color value. Values cannot be changed manually and must be changed via a function. local OSGL = require(path.to.osgl) local color = OSGL.color -- All other parameters are defaulted -- to 0, except for alpha, which is -- defaulted to 255. local myAwesomeRedColor = color.new(255)   "},{"title":"read​","type":1,"pageTitle":"Color","url":"/osgl-graphics/api/Color#read","content":"&lt;/&gt; Color.read( rgbaColor: Color-- The color to read ) → {number} Reads the value of the color local OSGL = require(path.to.osgl) local color = OSGL.color -- All other parameters are defaulted to 0, except for alpha, -- which is defaulted to 255. local myAwesomeRedColor = color.new(255) print(color.read(myAwesomeRedColor)) -- Output: { 255, 0, 0, 255 }   "},{"title":"r​","type":1,"pageTitle":"Color","url":"/osgl-graphics/api/Color#r","content":"&lt;/&gt; Color.r( color: Color-- The color to read ) → number Reads the 'r' value of the color local OSGL = require(path.to.osgl) local color = OSGL.color -- All other parameters are defaulted to 0, except for alpha, -- which is defaulted to 255. local myAwesomeRedColor = color.new(255) print color.r(myAwesomeRedColor)) -- Ouput: 255   "},{"title":"g​","type":1,"pageTitle":"Color","url":"/osgl-graphics/api/Color#g","content":"&lt;/&gt; Color.g( color: Color-- The color to read ) → number Reads the 'g' value of the color local OSGL = require(path.to.osgl) local color = OSGL.color -- All other parameters are defaulted to 0, except for alpha, -- which is defaulted to 255. local myAwesomeRedColor = color.new(255) print color.g(myAwesomeRedColor)) -- Ouput: 0   "},{"title":"b​","type":1,"pageTitle":"Color","url":"/osgl-graphics/api/Color#b","content":"&lt;/&gt; Color.b( color: Color-- The color to read ) → number Reads the 'b' value of the color local OSGL = require(path.to.osgl) local color = OSGL.color -- All other parameters are defaulted to 0, except for alpha, -- which is defaulted to 255. local myAwesomeRedColor = color.new(255) print color.b(myAwesomeRedColor)) -- Ouput: 0   "},{"title":"a​","type":1,"pageTitle":"Color","url":"/osgl-graphics/api/Color#a","content":"&lt;/&gt; Color.a( color: Color-- The color to read ) → number Reads the 'a' value of the color local OSGL = require(path.to.osgl) local color = OSGL.color -- All other parameters are defaulted to 0, except for alpha, -- which is defaulted to 255. local myAwesomeRedColor = color.new(255) print(color.a(myAwesomeRedColor)) -- Ouput: 255  "}]