[{"title":"Sprite","type":0,"sectionRef":"#","url":"/osgl-graphics/api/Sprite","content":"","keywords":""},{"title":"Types​","type":1,"pageTitle":"Sprite","url":"/osgl-graphics/api/Sprite#types","content":" "},{"title":"Sprite​","type":1,"pageTitle":"Sprite","url":"/osgl-graphics/api/Sprite#Sprite","content":"&lt;/&gt; interface Sprite { texture: Texture-- The sprites' texture color: Color-- The color of the sprite x: number-- The X position of the sprite y: number-- The Y position of the sprite } A Sprite can be drawn onto onto the screen to display a Texture "},{"title":"Functions​","type":1,"pageTitle":"Sprite","url":"/osgl-graphics/api/Sprite#functions","content":" "},{"title":"new​","type":1,"pageTitle":"Sprite","url":"/osgl-graphics/api/Sprite#new","content":"&lt;/&gt; Sprite.new( Texture: Texture-- The texture of the sprite ) → Sprite-- The new sprite Creates a new sprite local OSGL = require(path.to.osgl) local Sprite = OSGL.Sprite ​ local txt -- *load texture* local mySprite = Sprite.new(txt)   "},{"title":"Draw​","type":1,"pageTitle":"Sprite","url":"/osgl-graphics/api/Sprite#Draw","content":"&lt;/&gt; Sprite.Draw( self: types.Sprite&lt;P&gt;, to: DrawableObject-- The window, or texture, the sprite will be drawn on. ) → () Creates a new sprite on the given window or texture. local OSGL = require(path.to.osgl) local Window = OSGL.Window local Sprite = OSGL.Sprite ​ -- Creates a window from an existing EditableImage local myWindow = Window.from(path.to.editableImage, { sizeX = 50, sizeY = 50 }) local txt = -- *load texture* local mySprite = Sprite.new(myWindow, txt) mySprite:Draw(myWindow) -- Draws the sprite onto the window at 0, 0  "},{"title":"Texture","type":0,"sectionRef":"#","url":"/osgl-graphics/api/Texture","content":"","keywords":""},{"title":"Types​","type":1,"pageTitle":"Texture","url":"/osgl-graphics/api/Texture#types","content":" "},{"title":"FlagTexture​","type":1,"pageTitle":"Texture","url":"/osgl-graphics/api/Texture#FlagTexture","content":"&lt;/&gt; type FlagTexture = { width: number, height: number, pixels: {Color | string}, } The representation of a texture made with the converter exe provided with the module.  "},{"title":"Texture​","type":1,"pageTitle":"Texture","url":"/osgl-graphics/api/Texture#Texture","content":"&lt;/&gt; interface Texture { pixelStorage: PixelStorage-- The raw-bytes of the texture sizeX: number-- The width of the texture sizeY: number-- The height of the texture } A Texture can be drawn onto a Sprite to be displayed on-screen. Textures are simply a wrapper over our internal PixelStorage. "},{"title":"Functions​","type":1,"pageTitle":"Texture","url":"/osgl-graphics/api/Texture#functions","content":" "},{"title":"from​","type":1,"pageTitle":"Texture","url":"/osgl-graphics/api/Texture#from","content":"&lt;/&gt; Texture.from( textureData: FlagTexture | ModuleScript -- The string that was generated by the converter exe ) → types.Texture&lt;P&gt; Loads a texture from a string, or a module that returns a string. local OSGL = require(path.to.osgl) local Window = OSGL.Window local texture = OSGL.texture ​ -- Creates a window from an existing EditableImage local myWindow = Window.from(path.to.editableImage, { sizeX = 50, sizeY = 50 }) local txt = texture.from(script.ModuleThatReturnsTexture)   "},{"title":"new​","type":1,"pageTitle":"Texture","url":"/osgl-graphics/api/Texture#new","content":"&lt;/&gt; Texture.new( sizeX: number,-- The width of the texture sizeY: number-- The height of the texture ) → Texture-- The final texture Creates a texture of the given width and height local OSGL = require(path.to.osgl) local Window = OSGL.Window local texture = OSGL.texture ​ -- Creates a window from an existing EditableImage local myWindow = Window.from(path.to.editableImage, { sizeX = 50, sizeY = 50 }) local txt = texture.new(50, 50)   "},{"title":"read​","type":1,"pageTitle":"Texture","url":"/osgl-graphics/api/Texture#read","content":"&lt;/&gt; Texture.read( from: DrawableObject,-- The DrawableObject that will be read x: number,-- The X position of the area that will be read y: number,-- The position of the area that will be read xSize: number?,-- The X-Size of the chunk. Defaults to 1 ySize: number?-- The Y-Size of the chunk. Defaults to 1 ) → {types.Color}-- The colors in the specified chunk Reads the desired chunk from a DrawableObject object local OSGL = require(path.to.osgl) local Window = OSGL.Window local texture = OSGL.texture ​ -- Creates a window from an existing EditableImage local myWindow = Window.from(path.to.editableImage, { sizeX = 50, sizeY = 50 }) -- *Draw somthing here* -- Read a 5x5 square chunk, with the top-left corner -- being at 0, 0. This will return an array of colors -- of length 25 (assuming the window isn't smaller than 5x5 pixels) print(texture.read(myWindow, 0, 0, 5, 5))  "},{"title":"Errors","type":1,"pageTitle":"Texture","url":"/osgl-graphics/api/Texture##","content":"Type\tDescription&quot;X&quot;\tThis error occurs if the X is less than 0 &quot;Y&quot;\tThis error occurs if the Y is less than 0 &quot;XSize&quot;\tThis error occurs if the XSize is less than 1 &quot;YSize&quot;\tThis error occurs if the YSize is less than 1 "},{"title":"Setting up your environment","type":0,"sectionRef":"#","url":"/osgl-graphics/docs/setting-up-the-env","content":"Setting up your environment Before we can use OSGL, there are a few things we need to do first. Firstly, we need to make sure that we have the EditableImage beta enabled in Studio. You can enable it in File &gt; Beta Features &gt; EditableImages &amp; EditableMeshes If you haven't already, grab yourself the latest copy of OSGL from the github or the Roblox Marketplace, and insert it into Studio in a suitible place (such as ReplicatedStorage/Packages) Create an ImageLabel in StarterGui, with its BackgroundTransparency set to 0. This ImageLabel will serve as your canvas: note Lower resolutions cause blurred images! If you're rendering at a low resolution, or just want a pixelated look, set the ResampleMode property of your ImageLabel to Pixelated! Additionally, create a LocalScript in your desired location (e.g., StarterPlayer/StarterPlayerScripts ). This script will create our window and manage the rendering process. Now we can start programming!","keywords":""},{"title":"Drawing Shapes","type":0,"sectionRef":"#","url":"/osgl-graphics/docs/Shapes/drawing-shapes","content":"Drawing Shapes Below is a list of shapes in OSGL as of version 1.3b: Shape\tSupported\tSupports Rotation\tSupports Stroke\tNotesPixel\t✅\tN/A\tN/A Rectangle\t✅\t✅\t✅ Circle\t✅\t✅\t✅\tRotation is only visible at low resolutions. Lines\t✅\tN/A\t❌ Points\t✅\tN/A\t❌ Triangle\t❌\tN/A\tN/A\tWill be implemented All shape-drawing functions can be accessed through the draw sub-module of OSGL. The first argument for each function is a DrawableObject, which could be a Window or Texture. You'll also need to provide the relevant properties to define the shape (e.g., position, size, color). Here's an example of drawing a rectangle: draw.rectangle(window, { xPos = 0, yPos = 0, width = 5, height = 5, fillColor = color.RED, -- Rotation defaults to 0. -- Strokes are completely optional strokeColor = color.BLACK, strokeThickness = 2 }) Notes: Rotation: Most shapes support rotation, but in some cases (e.g., circles), the rotation is only visible at low resolutions. Stroke: For shapes that support strokes, you can define both the stroke color and thickness. However, strokes are entirely optional and can be omitted if not needed.","keywords":""},{"title":"DrawableObject","type":0,"sectionRef":"#","url":"/osgl-graphics/api/DrawableObject","content":"","keywords":""},{"title":"Functions​","type":1,"pageTitle":"DrawableObject","url":"/osgl-graphics/api/DrawableObject#functions","content":" "},{"title":"GetRelativeMouse​","type":1,"pageTitle":"DrawableObject","url":"/osgl-graphics/api/DrawableObject#GetRelativeMouse","content":"&lt;/&gt; DrawableObject.GetRelativeMouse(self: DrawableObject&lt;P&gt;) → ( boolean, number, number )-- Is mouse in window, mouse X, mouse Y Gets the mouse position relative to the window or texture local OSGL = require(path.to.osgl) local draw = OSGL.draw local Window = OSGL.Window local color = OSGL.color -- Creates a new EditableImage local myWindow = Window.new(path.to.parent, { sizeX = 50, sizeY = 50 }) print(myWindow:GetRelativeMouse()) print(&quot;The window has been destroyed.&quot;)   "},{"title":"ReadPixel​","type":1,"pageTitle":"DrawableObject","url":"/osgl-graphics/api/DrawableObject#ReadPixel","content":"&lt;/&gt; DrawableObject.ReadPixel( self: DrawableObject&lt;P&gt;, x: number, y: number ) → Color Reads a pixel at the given location local OSGL = require(path.to.osgl) local draw = OSGL.draw local Window = OSGL.Window local color = OSGL.color -- Creates a new EditableImage local myWindow = Window.new(path.to.parent, { sizeX = 50, sizeY = 50 }) draw.pixel(1, 1, color.RED) myWindow:Render() print(color.r(myWindow:ReadPixel(1, 1))) -- 255   "},{"title":"WritePixel​","type":1,"pageTitle":"DrawableObject","url":"/osgl-graphics/api/DrawableObject#WritePixel","content":"&lt;/&gt; DrawableObject.WritePixel( self: DrawableObject&lt;P&gt;, x: number, y: number, newColor: types.Color ) → () Writes a pixel at the given location local OSGL = require(path.to.osgl) local draw = OSGL.draw local Window = OSGL.Window local color = OSGL.color -- Creates a new EditableImage local myWindow = Window.new(path.to.parent, { sizeX = 50, sizeY = 50 }) myWindow:WritePixel(1, 1, color.RED)   "},{"title":"Tint​","type":1,"pageTitle":"DrawableObject","url":"/osgl-graphics/api/DrawableObject#Tint","content":"&lt;/&gt; DrawableObject.Tint( self: DrawableObject&lt;P&gt;, tint: types.Color, tintFactor: number ) → () Tints the entire of a window or texture local OSGL = require(path.to.osgl) local draw = OSGL.draw local Window = OSGL.Window local color = OSGL.color -- Creates a new EditableImage local myWindow = Window.new(path.to.parent, { sizeX = 50, sizeY = 50 }) myWindow:Tint(color.RED, .5)   "},{"title":"TintRegion​","type":1,"pageTitle":"DrawableObject","url":"/osgl-graphics/api/DrawableObject#TintRegion","content":"&lt;/&gt; DrawableObject.TintRegion( self: DrawableObject&lt;P&gt;, tint: types.Color, tintFactor: number, x: number, y: number, width: number, height: number ) → () Tints a section of a window or texture local OSGL = require(path.to.osgl) local draw = OSGL.draw local Window = OSGL.Window local color = OSGL.color -- Creates a new EditableImage local myWindow = Window.new(path.to.parent, { sizeX = 50, sizeY = 50 }) myWindow:TintRegion(color.RED, .5, 1, 1, 25, 25)   "},{"title":"FloodFill​","type":1,"pageTitle":"DrawableObject","url":"/osgl-graphics/api/DrawableObject#FloodFill","content":"&lt;/&gt; DrawableObject.FloodFill( self: DrawableObject&lt;P&gt;, newColor: types.Color, x: number?, y: number? ) → () Fills a section of a window or texture with a color local OSGL = require(path.to.osgl) local draw = OSGL.draw local Window = OSGL.Window local color = OSGL.color -- Creates a new EditableImage local myWindow = Window.new(path.to.parent, { sizeX = 50, sizeY = 50 }) myWindow:FloodFill(color.RED, 5, 5)  "},{"title":"Introduction","type":0,"sectionRef":"#","url":"/osgl-graphics/docs/intro","content":"","keywords":""},{"title":"What This Documentation Covers​","type":1,"pageTitle":"Introduction","url":"/osgl-graphics/docs/intro#what-this-documentation-covers","content":"In this guide, you'll learn how to: Open a window using OSGL.Draw pixels, shapes, and other graphical elements such as sprites to the window. This documentation assumes you have a basic understanding of Luau. If you're new, you can find plenty of resources online! "},{"title":"Window","type":0,"sectionRef":"#","url":"/osgl-graphics/api/Window","content":"","keywords":""},{"title":"Types​","type":1,"pageTitle":"Window","url":"/osgl-graphics/api/Window#types","content":" "},{"title":"Window​","type":1,"pageTitle":"Window","url":"/osgl-graphics/api/Window#Window","content":"&lt;/&gt; interface Window { renderer: EditableImage -- The actual EditableImage instance. pixels: {Color}-- An array of color values. } An OSGL window is the representation of the EditableImage instance. A window can be created by importing the OSGL 'window' submodule: local OSGL = require(path.to.osgl) local Window = OSGL.Window ​ -- Creates a window from an existing EditableImage local myWindow = Window.from(path.to.editableImage)   "},{"title":"WindowConfiguration​","type":1,"pageTitle":"Window","url":"/osgl-graphics/api/Window#WindowConfiguration","content":"&lt;/&gt; interface WindowConfiguration { sizeX: number-- The width of the OSGL window. The maximum width is 1024. Defaults to 100 sizeY: number-- The height of the OSGL window. The maximum height is 1024. Defaults to 100 } An OSGL window is the representation of the EditableImage instance. A window can be created by importing the OSGL 'window' submodule: local OSGL = require(path.to.osgl) local Window = OSGL.Window ​ -- Creates a Window with a size of 50x50 local myWindow = Window.new(path.to.instance, { sizeX = 50, sizeY = 50 })  "},{"title":"Functions​","type":1,"pageTitle":"Window","url":"/osgl-graphics/api/Window#functions","content":" "},{"title":"new​","type":1,"pageTitle":"Window","url":"/osgl-graphics/api/Window#new","content":"&lt;/&gt; Window.new( parent: Instance ,-- The instance the EditableImage will be parented to config: WindowConfiguration?-- Optional configurations ) → Window-- Returns an OSGL window instance Creates an OSGL window by creating a new EditableImage instance at the given place. local OSGL = require(path.to.osgl) local Window = OSGL.Window ​ -- Creates a new Window local myWindow = Window.new(path.to.parent, { sizeX = 50, sizeY = 50 })  "},{"title":"Errors","type":1,"pageTitle":"Window","url":"/osgl-graphics/api/Window##","content":"Type\tDescription&quot;Argument Type&quot;\tThis error occurs when a required argument is not passed or the type is incorrect  "},{"title":"from​","type":1,"pageTitle":"Window","url":"/osgl-graphics/api/Window#from","content":"&lt;/&gt; Window.from( editableImage: EditableImage -- The existing EditableImage ) → Window-- Returns an OSGL window instance Creates an OSGL window from an existing EditableImage. local OSGL = require(path.to.osgl) local Window = OSGL.Window ​ -- Creates a window from an existing EditableImage local myWindow = Window.from(path.to.editableImage, { size = Vector2.new(50, 50) })  "},{"title":"Errors","type":1,"pageTitle":"Window","url":"/osgl-graphics/api/Window##","content":"Type\tDescription&quot;Argument Type&quot;\tThis error occurs when a required argument is not passed or the type is incorrect  "},{"title":"IsOpen​","type":1,"pageTitle":"Window","url":"/osgl-graphics/api/Window#IsOpen","content":"&lt;/&gt; Window.IsOpen( self: Window&lt;P&gt;, yield: number?-- The amount of time to yield. Defaults to a heartbeat. ) → boolean Returns if the OSGL Window still exists. Useful for game-loops. Automatically yields for a heartbeat, or the given time. local OSGL = require(path.to.osgl) local Window = OSGL.Window -- Creates a new Window local myWindow = Window.new(path.to.parent, { sizeX = 50, sizeY = 50 }) -- Runs every heartbeat while myWindow:IsOpen() do print(&quot;Window exists!&quot;) end print(&quot;The window has been destroyed.&quot;)  "},{"title":"Errors","type":1,"pageTitle":"Window","url":"/osgl-graphics/api/Window##","content":"Type\tDescription&quot;Argument Type&quot;\tThis error occurs when a required argument is not passed or the type is incorrect  "},{"title":"Render​","type":1,"pageTitle":"Window","url":"/osgl-graphics/api/Window#Render","content":"&lt;/&gt; Window.Render(self: Window&lt;P&gt;) → () Renders Window.pixels to the EditableImage local OSGL = require(path.to.osgl) local Window = OSGL.Window -- Creates a new Window local myWindow = Window.new(path.to.parent, { sizeX = 50, sizeY = 50 }) -- Runs every heartbeat while myWindow:IsOpen() do -- *rendering magic* myWindow:Render() end   "},{"title":"Clear​","type":1,"pageTitle":"Window","url":"/osgl-graphics/api/Window#Clear","content":"&lt;/&gt; Window.Clear( self: Window&lt;P&gt;, clearColor: Color?-- The color the screen will be cleared with ) → () Clears the double-buffer with the given color or a transparent color local OSGL = require(path.to.osgl) local Window = OSGL.Window local color = OSGL.color -- Creates a new EditableImage local myWindow = Window.new(path.to.parent, { sizeX = 50, sizeY = 50 }) -- Runs every heartbeat while myWindow:IsOpen() do myWindow:Clear(color.GREEN) myWindow:Render() end   "},{"title":"Resize​","type":1,"pageTitle":"Window","url":"/osgl-graphics/api/Window#Resize","content":"&lt;/&gt; Window.Resize( self: Window&lt;P&gt;, newWidth: number?,-- The new width of the window newHeight: number?-- The new height of the window ) → () Resizes the window and its pixel buffer. This function may be resource intensive and is not made for constant use. May require a re-render, depending on the new size. local OSGL = require(path.to.osgl) local Window = OSGL.Window local color = OSGL.color -- Creates a new Window local myWindow = Window.new(path.to.parent, { sizeX = 50, sizeY = 50 }) myWindow:Resize(100) -- Changes width to 100 -- Runs every heartbeat while myWindow:IsOpen() do -- *rendering magic* myWindow:Render() end  "},{"title":"Errors","type":1,"pageTitle":"Window","url":"/osgl-graphics/api/Window##","content":"Type\tDescription&quot;Height&quot;\tThis error occurs if the height is smaller than 0 &quot;Width&quot;\tThis error occurs if the width is smaller than 0 "},{"title":"Loading Textures","type":0,"sectionRef":"#","url":"/osgl-graphics/docs/Sprites/loading-textures","content":"Loading Textures To load file formats such as PNGs, WebPs, etc., OSGL uses its own external tool. The tool is bundled with OSGL on the github releases page, here, named image-converter (previously converter). Pick the one for your OS. If you don't know which to pick, feel free to ask us! note You can get help with the image-converter exe by running it in the command-prompt, with the -h flag! e.g: &gt; image-converter -h The image-converter turns these image formats into OSGLs custom image-format, which you can learn more about here. We can load textures into OSGL with the texture.from function, which takes the texture generated by the image-converter: local OSGL = require(path.to.osgl) local texture = OSGL.texture ​ local txt = texture.from(script.ModuleThatReturnsTexture) -- &quot;txt&quot; now contains OSGL-Texture data You can also create a blank texture of the given width, and height, with the texture.new function: local OSGL = require(path.to.osgl) local texture = OSGL.texture ​ local txt = texture.new(50, 50) -- Creates a 50x50 texture info Remember, like Windows, Textures can also be drawn to! You can edit a texture like any other window by passing it as the first argument of a draw function.","keywords":""},{"title":"Draw","type":0,"sectionRef":"#","url":"/osgl-graphics/api/Draw","content":"","keywords":""},{"title":"Types​","type":1,"pageTitle":"Draw","url":"/osgl-graphics/api/Draw#types","content":" "},{"title":"Points​","type":1,"pageTitle":"Draw","url":"/osgl-graphics/api/Draw#Points","content":"&lt;/&gt; type Points = {{number}} An array of points "},{"title":"Functions​","type":1,"pageTitle":"Draw","url":"/osgl-graphics/api/Draw#functions","content":" "},{"title":"pixel​","type":1,"pageTitle":"Draw","url":"/osgl-graphics/api/Draw#pixel","content":"&lt;/&gt; Draw.pixel( window: DrawableObject,-- The window or texture to draw on xPos: number,-- The X-Position of the pixel, yPos: number,-- The Y-Position of the pixel color: Color-- The color of the pixel ) → nil Draws a singular pixel at the given location local OSGL = require(path.to.osgl) local draw = OSGL.draw local Window = OSGL.Window local color = OSGL.color -- Creates a new EditableImage local myWindow = Window.new(path.to.parent, { sizeX = 50, sizeY = 50 }) -- Runs every heartbeat while myWindow:IsOpen() do -- Render here -- Draws a pixel at 0, 0, with a red color, onto &quot;myWindow&quot; draw.pixel(myWindow, 0, 0, color.RED) -- Stop rendering here myWindow:Render() end print(&quot;The window has been destroyed.&quot;)  "},{"title":"Errors","type":1,"pageTitle":"Draw","url":"/osgl-graphics/api/Draw##","content":"Type\tDescription&quot;X&quot;\tThis error occurs if the X is less than 0 &quot;Y&quot;\tThis error occurs if the Y is less than 0  "},{"title":"line​","type":1,"pageTitle":"Draw","url":"/osgl-graphics/api/Draw#line","content":"&lt;/&gt; Draw.line( window: DrawableObject,-- The window or texture to draw on line: { startX: number, startY: number, stopX: number, stopY: number, thickness: number, color: Color? }-- The data that is used to construct the line ) → nil Draws a line from point A to point B local OSGL = require(path.to.osgl) local draw = OSGL.draw local Window = OSGL.Window local color = OSGL.color -- Creates a new EditableImage local myWindow = Window.new(path.to.parent, { sizeX = 50, sizeY = 50 }) -- Runs every heartbeat while myWindow:IsOpen() do -- Render here -- Draws a red line from 0,0 to 29,29 draw.line(myWindow, { startX = 0, startY = 0, stopX = 29, stopY = 29, -- Thickness defaults to 1 -- Color defaults to black color = color.RED }) -- Stop rendering here myWindow:Render() end print(&quot;The window has been destroyed.&quot;)   "},{"title":"circle​","type":1,"pageTitle":"Draw","url":"/osgl-graphics/api/Draw#circle","content":"&lt;/&gt; Draw.circle( window: DrawableObject,-- The window or texture to draw on circle: { centerX: number, centerY: number, radius: number, fillColor: Color?, strokeColor: Color?, strokeThickness: number?, rotation: number? }-- The data that is used to construct the circle ) → nil Draws a circle with an optional stroke onto the screen local OSGL = require(path.to.osgl) local Draw = OSGL.draw local Window = OSGL.Window local color = OSGL.color -- Creates a new EditableImage local myWindow = Window.new(path.to.parent, { sizeX = 50, sizeY = 50 }) -- Runs every heartbeat while myWindow:IsOpen() do -- Render here -- Draw our circle myWindow:Clear(color.TRANSPARENT) draw.circle(myWindow, { centerX = 25, centerY = 25, radius = 10, fillColor = color.RED, -- Rotation defaults to 0. -- Strokes are completely optional strokeColor = color.BLACK, strokeThickness = 2 }) -- Stop rendering here myWindow:Render() end print(&quot;The window has been destroyed.&quot;)   "},{"title":"rectangle​","type":1,"pageTitle":"Draw","url":"/osgl-graphics/api/Draw#rectangle","content":"&lt;/&gt; Draw.rectangle( window: DrawableObject,-- The window or texture to draw on rectangle: { xPos: number, yPos: number, width: number, height: number, fillColor: Color?, strokeColor: Color?, strokeThickness: number?, rotation: number? }-- The data that is used to construct the rectangle ) → nil Draws a rectangle with an optional stroke on the screen local OSGL = require(path.to.osgl) local draw = OSGL.draw local Window = OSGL.Window local color = OSGL.color -- Creates a new EditableImage local myWindow = Window.new(path.to.parent, { sizeX = 50, sizeY = 50 }) -- Runs every heartbeat while myWindow:IsOpen() do -- Render here -- Draws a square (5x5) at 0, 0, with a red color, onto &quot;myWindow&quot; draw.rectangle(myWindow, { xPos = 0, yPos = 0, width = 5, height = 5, fillColor = color.RED, -- Rotation defaults to 0. -- Strokes are completely optional strokeColor = color.BLACK, strokeThickness = 2 }) -- Stop rendering here myWindow:Render() end print(&quot;The window has been destroyed.&quot;)   "},{"title":"points​","type":1,"pageTitle":"Draw","url":"/osgl-graphics/api/Draw#points","content":"&lt;/&gt; Draw.points( window: DrawableObject,-- The window or texture to draw on points: { x: number, y: number, points: Points, fillColor: Color }-- The data which is used to construct the shape ) → nil Draws a shape from the given points local OSGL = require(path.to.osgl) local draw = OSGL.draw local Window = OSGL.Window local color = OSGL.color -- Creates a new EditableImage local myWindow = Window.new(path.to.parent, { sizeX = 50, sizeY = 50 }) -- An array of points (x, y) local points = { { 0, 0 }, { 6, 0 }, { 6, 6 }, { 0, 6 }, } -- Runs every heartbeat while myWindow:IsOpen() do -- Render here -- Draws a square at 0, 0, with a red color, onto &quot;myWindow&quot; draw.points(myWindow, { points = points, color = color.RED, x = 0, y = 0, }) -- Stop rendering here myWindow:Render() end print(&quot;The window has been destroyed.&quot;)  "},{"title":"Errors","type":1,"pageTitle":"Draw","url":"/osgl-graphics/api/Draw##","content":"Type\tDescription&quot;X&quot;\tThis error occurs if the X is smaller than 0 &quot;Y&quot;\tThis error occurs if the Y is smaller than 0 &quot;Points&quot;\tThis error occurs if 2 or less points are provided "},{"title":"Color","type":0,"sectionRef":"#","url":"/osgl-graphics/api/Color","content":"","keywords":""},{"title":"Types​","type":1,"pageTitle":"Color","url":"/osgl-graphics/api/Color#types","content":" "},{"title":"Color​","type":1,"pageTitle":"Color","url":"/osgl-graphics/api/Color#Color","content":"&lt;/&gt; type Color = number local OSGL = require(path.to.osgl) local color = OSGL.color ​ -- All other parameters are defaulted -- to 0, except for alpha, which is -- defaulted to 255. local myAwesomeRedColor = color.new(255)  "},{"title":"Properties​","type":1,"pageTitle":"Color","url":"/osgl-graphics/api/Color#properties","content":" "},{"title":"RED​","type":1,"pageTitle":"Color","url":"/osgl-graphics/api/Color#RED","content":"&lt;/&gt; Color.RED: Color A red color  "},{"title":"GREEN​","type":1,"pageTitle":"Color","url":"/osgl-graphics/api/Color#GREEN","content":"&lt;/&gt; Color.GREEN: Color A green color  "},{"title":"BLUE​","type":1,"pageTitle":"Color","url":"/osgl-graphics/api/Color#BLUE","content":"&lt;/&gt; Color.BLUE: color A blue color  "},{"title":"WHITE​","type":1,"pageTitle":"Color","url":"/osgl-graphics/api/Color#WHITE","content":"&lt;/&gt; Color.WHITE: Color A white color  "},{"title":"BLACK​","type":1,"pageTitle":"Color","url":"/osgl-graphics/api/Color#BLACK","content":"&lt;/&gt; Color.BLACK: Color A black color  "},{"title":"YELLOW​","type":1,"pageTitle":"Color","url":"/osgl-graphics/api/Color#YELLOW","content":"&lt;/&gt; Color.YELLOW: Color A yellow color  "},{"title":"MAGENTA​","type":1,"pageTitle":"Color","url":"/osgl-graphics/api/Color#MAGENTA","content":"&lt;/&gt; Color.MAGENTA: Color A magenta color  "},{"title":"CYAN​","type":1,"pageTitle":"Color","url":"/osgl-graphics/api/Color#CYAN","content":"&lt;/&gt; Color.CYAN: Color A cyan color  "},{"title":"TRANSPARENT​","type":1,"pageTitle":"Color","url":"/osgl-graphics/api/Color#TRANSPARENT","content":"&lt;/&gt; Color.TRANSPARENT: Color A completely transparent color "},{"title":"Functions​","type":1,"pageTitle":"Color","url":"/osgl-graphics/api/Color#functions","content":" "},{"title":"new​","type":1,"pageTitle":"Color","url":"/osgl-graphics/api/Color#new","content":"&lt;/&gt; Color.new( r: number?, g: number?, b: number?, a: number? ) → Color-- Returns a color Value Creates a new color value. Values cannot be changed manually and must be changed via a function. local OSGL = require(path.to.osgl) local color = OSGL.color -- All other parameters are defaulted -- to 0, except for alpha, which is -- defaulted to 255. local myAwesomeRedColor = color.new(255)   "},{"title":"newRGB​","type":1,"pageTitle":"Color","url":"/osgl-graphics/api/Color#newRGB","content":"&lt;/&gt; Color.newRGB( r: number?, g: number?, b: number? ) → Color-- Returns a color Value Creates a new color value with the alpha channel being 255. Values cannot be changed manually and must be changed via a function. local OSGL = require(path.to.osgl) local color = OSGL.color -- All other parameters are defaulted -- to 0. local myAwesomeRedColor = color.newRGB(255)   "},{"title":"setR​","type":1,"pageTitle":"Color","url":"/osgl-graphics/api/Color#setR","content":"&lt;/&gt; Color.setR( c: Color,-- The color to edit r: number-- The new value ) → number Sets the 'r' channel of the color. local OSGL = require(path.to.osgl) local color = OSGL.color local c = color.setR(color.RED, 100) print(color.r(c)) -- Ouput: 100 For performance boost, if you're creating colors using only 1 or 2 channels, you should do: local almostRed = color.setR(color.BLACK, 100)   "},{"title":"setG​","type":1,"pageTitle":"Color","url":"/osgl-graphics/api/Color#setG","content":"&lt;/&gt; Color.setG( c: Color,-- The color to edit g: number-- The new value ) → number Sets the 'g' channel of the color. local OSGL = require(path.to.osgl) local color = OSGL.color local c = color.setG(color.GREEN, 100) print(color.g(c)) -- Ouput: 100 For performance boost, if you're creating colors using only 1 or 2 channels, you should do: local almostGreen = color.setG(color.BLACK, 100)   "},{"title":"setB​","type":1,"pageTitle":"Color","url":"/osgl-graphics/api/Color#setB","content":"&lt;/&gt; Color.setB( c: Color,-- The color to edit b: number-- The new value ) → number Sets the 'b' channel of the color. local OSGL = require(path.to.osgl) local color = OSGL.color local c = color.setB(color.BLUE, 100) print(color.b(c)) -- Ouput: 100 For performance boost, if you're creating colors using only 1 or 2 channels, you should do: local almostBlue = color.setB(color.BLACK, 100)   "},{"title":"setA​","type":1,"pageTitle":"Color","url":"/osgl-graphics/api/Color#setA","content":"&lt;/&gt; Color.setA( c: Color,-- The color to edit a: number-- The new value ) → number Sets the 'a' channel of the color. local OSGL = require(path.to.osgl) local color = OSGL.color local c = color.setA(color.TRANSPARENT, 100) print(color.a(c)) -- Ouput: 100 For performance boost, if you're creating colors using only 1 or 2 channels, you should do: local almostBlack = color.setA(color.TRANSPARENT, 100)   "},{"title":"read​","type":1,"pageTitle":"Color","url":"/osgl-graphics/api/Color#read","content":"&lt;/&gt; Color.read( rgbaColor: Color-- The color to read ) → {number} Reads the value of the color local OSGL = require(path.to.osgl) local color = OSGL.color -- All other parameters are defaulted to 0, except for alpha, -- which is defaulted to 255. local myAwesomeRedColor = color.new(255) print(color.read(myAwesomeRedColor)) -- Output: { 255, 0, 0, 255 }   "},{"title":"r​","type":1,"pageTitle":"Color","url":"/osgl-graphics/api/Color#r","content":"&lt;/&gt; Color.r( color: Color-- The color to read ) → number Reads the 'r' value of the color local OSGL = require(path.to.osgl) local color = OSGL.color -- All other parameters are defaulted to 0, except for alpha, -- which is defaulted to 255. local myAwesomeRedColor = color.new(255) print color.r(myAwesomeRedColor)) -- Ouput: 255   "},{"title":"g​","type":1,"pageTitle":"Color","url":"/osgl-graphics/api/Color#g","content":"&lt;/&gt; Color.g( color: Color-- The color to read ) → number Reads the 'g' value of the color local OSGL = require(path.to.osgl) local color = OSGL.color -- All other parameters are defaulted to 0, except for alpha, -- which is defaulted to 255. local myAwesomeRedColor = color.new(255) print color.g(myAwesomeRedColor)) -- Ouput: 0   "},{"title":"b​","type":1,"pageTitle":"Color","url":"/osgl-graphics/api/Color#b","content":"&lt;/&gt; Color.b( color: Color-- The color to read ) → number Reads the 'b' value of the color local OSGL = require(path.to.osgl) local color = OSGL.color -- All other parameters are defaulted to 0, except for alpha, -- which is defaulted to 255. local myAwesomeRedColor = color.new(255) print color.b(myAwesomeRedColor)) -- Ouput: 0   "},{"title":"a​","type":1,"pageTitle":"Color","url":"/osgl-graphics/api/Color#a","content":"&lt;/&gt; Color.a( color: Color-- The color to read ) → number Reads the 'a' value of the color local OSGL = require(path.to.osgl) local color = OSGL.color -- All other parameters are defaulted to 0, except for alpha, -- which is defaulted to 255. local myAwesomeRedColor = color.new(255) print(color.a(myAwesomeRedColor)) -- Ouput: 255   "},{"title":"tint​","type":1,"pageTitle":"Color","url":"/osgl-graphics/api/Color#tint","content":"&lt;/&gt; Color.tint( color1: Color,-- The color to tint color2: Color,-- The tint that will be applied factor: number-- How strong the tint is ) → number Tints the color towards the other color using a tint factor. A tint factor of 0 means color1 will be returned, while a tint factor of 1 means color2 will be returned. local OSGL = require(path.to.osgl) local color = OSGL.color local whiteTintedRed = color.tint(color.WHITE, color.RED)  "},{"title":"Custom OSGL Image-Format","type":0,"sectionRef":"#","url":"/osgl-graphics/docs/Sprites/custom-texture-format","content":"","keywords":""},{"title":"Colors​","type":1,"pageTitle":"Custom OSGL Image-Format","url":"/osgl-graphics/docs/Sprites/custom-texture-format#colors","content":"Colors are stored as a single 32-bit unsigned integer (u32). This allows for compact representation and fast manipulation of colors in the form of a single number. Each 32-bit color value is structured as four 8-bit components, representing the Red, Green, Blue, and Alpha (opacity) channels of the color. These components are packed into the 32-bit integer, with each component occupying one byte (8 bits). "},{"title":"Byte Layout of the Color​","type":1,"pageTitle":"Custom OSGL Image-Format","url":"/osgl-graphics/docs/Sprites/custom-texture-format#byte-layout-of-the-color","content":"The four components are stored in the following order, from the most significant byte to the least significant byte: First byte (bits 1-8): Red (R)Second byte (bits 9-16): Green (G)Third byte (bits 17-24): Blue (B)Fourth byte (bits 25-32): Alpha (A) This can be visualised as: R\tG\tB\tA8 bits\t8 bits\t8 bits\t8 bits 1-8\t9-16\t17-24\t25-32 For example, consider the color with the following components: Red (R): 255 (0xFF) Green (G): 128 (0x80) Blue (B): 64 (0x40) Alpha (A): 255 (0xFF) These components would be packed into a 32-bit integer as follows: Red (R): 255 (0xFF) -&gt; Occupies bits 24-31 Green (G): 128 (0x80) -&gt; Occupies bits 16-23 Blue (B): 64 (0x40) -&gt; Occupies bits 8-15 Alpha (A): 255 (0xFF) -&gt; Occupies bits 0-7 The resulting 32-bit integer representation would be: 0xFF8040FF (4286595327) "},{"title":"Planned updates","type":0,"sectionRef":"#","url":"/osgl-graphics/docs/Whats Next/planned-updates","content":"Planned updates Below is a list of possible upcoming OSGL features: Shapes: Triangles Fonts &amp; Texts","keywords":""},{"title":"Rendering with sprites","type":0,"sectionRef":"#","url":"/osgl-graphics/docs/Sprites/rendering-with-sprites","content":"Rendering with sprites A texture on its own cannot directly be drawn to the screen. Instead, it can be applied to a Sprite, which can render itself on the screen. Creating a sprite is as simple as: local OSGL = require(path.to.osgl) local Sprite = OSGL.Sprite ​ local txt -- *load texture* local mySprite = Sprite.new(txt) You can then render these sprites to a window (or even another texture) by using its Draw method: local OSGL = require(path.to.osgl) local Window = OSGL.Window local Sprite = OSGL.Sprite ​ -- Creates a window from an existing EditableImage local myWindow = Window.from(path.to.editableImage, { sizeX = 50, sizeY = 50 }) local txt = -- *load texture* local mySprite = Sprite.new(myWindow, txt) mySprite:Draw(myWindow) myWindow:Render() -- Don't forget to render! Sprites also have an X and Y positions, meaning you can change the position of the sprite on the screen.","keywords":""},{"title":"Opening a window","type":0,"sectionRef":"#","url":"/osgl-graphics/docs/Windows/opening-a-window","content":"Opening a window In OSGL, a &quot;window&quot; is actually just a fancy name for an EditableImage. All that OSGL does, is wrap this EditableImage in an easy-to-use API for you. With a lot of handy features. Before we can actually draw on our window, we need to create one. OSGL is split into sub-modules that each serve a different purpose (e.g, drawing on a window, creating a window, etc.). In this case, we want the Window class which allows us to create our window. local OSGL = require(ReplicatedStorage.Packages.OSGL) local Window = OSGL.Window There are two functions available for creating our window: Window.from and Window.new . According to the API: Window.from : Creates an OSGL window from an existing EditableImage.Window.new : Creates an OSGL window by initializing a new EditableImage instance at the specified location. Since we don’t have an existing EditableImage , we'll use Window.new to create our window on the designated ImageLabel: local OSGL = require(ReplicatedStorage.Packages.OSGL) local Window = OSGL.Window local windowUi = -- *reference to windowUi, our `ImageLabel`* -- Create our window, 500x500 local myWindow = Window.new(windowUi, { sizeX = 500, sizeY = 500 }) The example above creates an OSGL window, with a size of 500x500, under windowUi. You can find more details about this function in the API And that's it! We have our OSGL window ready and setup for rendering!","keywords":""},{"title":"Managing & Rendering to a window","type":0,"sectionRef":"#","url":"/osgl-graphics/docs/Windows/managing-and-rendering-to-a-window","content":"Managing &amp; Rendering to a window Now that we have our window, let's make this code a bit more interesting: local OSGL = require(ReplicatedStorage.Packages.OSGL) local Window = OSGL.Window local color = OSGL.color local windowUi -- reference to windowUi, our `ImageLabel` -- Create our window, 500x500 local myWindow = Window.new(windowUi, { sizeX = 500, sizeY = 500 }) while myWindow:IsOpen() do myWindow:Clear(color.BLACK) myWindow:Render() end In summary, the above code creates a window, and while it is open, clears the screen with a BLACK color (0, 0, 0, 255). The IsOpen method returns if our window still exists, yielding for a heartbeat, meaning we don't need to include a task.wait. The Clear method clears the Windows' buffer with the given color, which in this case is BLACK. Finally, we call the Render method, which, as the name suggests, renders the buffer to the screen. After the window is destroyed, the program will end. The color sub-module is used to manipulate OSGL colors (RGBA format). Using IsOpen is known as the &quot;event loop&quot; or the &quot;game loop&quot;. The contents of this loop are usually executed every frame. But what else can we do other than clear the buffer? We can utilize the draw sub-module to draw directly to the buffer. All drawing functions require a Window or Texture to draw to. For example, to draw a pixel: local OSGL = require(ReplicatedStorage.Packages.OSGL) local Window = OSGL.Window local color = OSGL.color local windowUi = -- *reference to windowUi, our `ImageLabel`* -- Create our window, 10x10 local myWindow = Window.new(windowUi, { sizeX = 10, sizeY = 10 }) while myWindow:IsOpen() do myWindow:Clear(color.BLACK) -- It isn't necessary to clear the screen. If you want to keep the contents -- of the previous frame, you can! -- Draw a red pixel on `myWindow`, at 0, 0 draw.pixel(myWindow, 0, 0, color.RED) myWindow:Render() end You can learn more about the different shapes you can draw in Drawing Shapes section!","keywords":""}]