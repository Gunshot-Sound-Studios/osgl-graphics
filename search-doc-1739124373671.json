{"searchDocs":[{"title":"Rendering fonts","type":0,"sectionRef":"#","url":"/osgl/docs/Fonts/rendering-fonts","content":"Rendering fonts You can draw a font onto a [DrawableObject] via the Draw function local OSGL = require(path.to.osgl) local Window = OSGL.Window local Font = OSGL.Font local WIDTH = 800 local HEIGHT = 600 -- Create a new window local myWindow = Window.new(parent, { sizeX = WIDTH, sizeY = HEIGHT }) -- Load a font local fnt = Font.from(fontData) fnt:Draw(&quot;Hello, World!&quot;, 1, 1) In this example, the text &quot;Hello, World!&quot; will be rendered at the coordinates (1, 1) on the window.","keywords":"","version":"Next"},{"title":"Multiple Renderers","type":0,"sectionRef":"#","url":"/osgl/docs/Advanced/multiple-renderers","content":"","keywords":"","version":"Next"},{"title":"Adding a Renderer​","type":1,"pageTitle":"Multiple Renderers","url":"/osgl/docs/Advanced/multiple-renderers#adding-a-renderer","content":" To add a renderer to a Window, utilize the AddRenderer method. This method accepts a variadic list of Images as arguments and appends them to the Window's renderer list. This allows the Window to render multiple images concurrently.  window:AddRenderer(imageOne, imageTwo)   ","version":"Next","tagName":"h2"},{"title":"Removing a Renderer​","type":1,"pageTitle":"Multiple Renderers","url":"/osgl/docs/Advanced/multiple-renderers#removing-a-renderer","content":" Conversely, to remove a renderer from a Window, use the RemoveRenderer method. This method also accepts a variadic list of Images as arguments. If the specified Images are currently being rendered by the Window, they will be removed from the renderer list:  window:RemoveRenderer(imageOne)  ","version":"Next","tagName":"h2"},{"title":"Loading Fonts","type":0,"sectionRef":"#","url":"/osgl/docs/Fonts/loading-fonts","content":"Loading Fonts To load fonts such as ttf, etc., OSGL uses its own external tool. The tool is bundled with OSGL on the github releases page, here. Pick the one for your OS. If you don't know which to pick, feel free to ask us! note You can get help with the exe by running it in the command-prompt, with the -h flag! e.g: &gt; font-converter -h You can load fonts into OSGL with the Font.from function, which takes the font generated by the font-converter: local OSGL = require(path.to.osgl) local Font = OSGL.Font ​ local fnt = Font.from(script.ModuleThatReturnsFont) -- &quot;fnt&quot; now contains the loaded font ","keywords":"","version":"Next"},{"title":"Serializing & Deserializing","type":0,"sectionRef":"#","url":"/osgl/docs/Advanced/serializing-and-deserializing","content":"","keywords":"","version":"Next"},{"title":"Why Serialize and Deserialize?​","type":1,"pageTitle":"Serializing & Deserializing","url":"/osgl/docs/Advanced/serializing-and-deserializing#why-serialize-and-deserialize","content":" Consider a scenario where you have two Windows: Window A and Window B. You want to copy the contents of A into B. Typically, you might do something like this:  local B = Window.fromBuffer(A.buffer, configuration)   However, if B is not the same size as A, an error will occur. This is where serialization and deserialization become useful. You can serialize a Window and deserialize it into another Window or even a Texture:  local A = Window.new(parent, { sizeX = 50, sizeY = 50 }) -- Draw a texture to `A` local txt = texture.fromAssetId(14419725604) texture.draw(A, txt, 0, 0) -- Serialize `A` to get its buffer, width, and height local bfr, w, h = A:Serialize() local B = Window.new(parentTwo, { sizeX = 2, sizeY = 10 }) -- Resize `B` to match `A`'s dimensions and paste the contents B:Deserialize(bfr, w, h) -- Now `B` has the same size and contents as `A` B:Render()   ","version":"Next","tagName":"h3"},{"title":"Understanding the Difference​","type":1,"pageTitle":"Serializing & Deserializing","url":"/osgl/docs/Advanced/serializing-and-deserializing#understanding-the-difference","content":" If you are certain about the sizes of the Windows, you can use fromBuffer. However, if you are unsure or need to resize dynamically, it is advisable to use Deserialize. The Deserialize function safely scales the size of the buffer. Directly setting the buffer to another buffer may cause size errors! It's always safer to use Deserialize, however if you are confident that both buffers will always be the same size, you can directly set the buffer via:  A.buffer = B.buffer   ","version":"Next","tagName":"h3"},{"title":"Serializing Textures​","type":1,"pageTitle":"Serializing & Deserializing","url":"/osgl/docs/Advanced/serializing-and-deserializing#serializing-textures","content":" Textures can also be serialized:  local txt = texture.fromAssetId(14419725604) local bfr, w, h = txt:Serialize() -- Create a new window with the texture's contents local window = Window.fromBuffer(bfr, { sizeX = w, sizeY = h }) -- Alternatively, use `Deserialize` to update an existing window: local secondWindow = -- *reference to a window* secondWindow:Deserialize(bfr, w, h)   ","version":"Next","tagName":"h3"},{"title":"Saving and Loading Example​","type":1,"pageTitle":"Serializing & Deserializing","url":"/osgl/docs/Advanced/serializing-and-deserializing#saving-and-loading-example","content":" Here is an example of how you can save and load the state of a Window using serialization and deserialization:  -- Save.luau local bfr, width, height = windowOne:Serialize() -- *save data* -- Load.luau local bfr, width, height = -- *load data* windowTwo:Deserialize(bfr, width, height)   In summary, while serialization and deserialization are powerful functions for managing Windows and Textures, there are times when directly setting the buffer with A.buffer = B.buffer might be more convenient. This approach can be useful when you are certain that the sizes of the buffers match, as it avoids the need to handle potential performance issues / resizing issues that come with deserialization. ","version":"Next","tagName":"h3"},{"title":"Font","type":0,"sectionRef":"#","url":"/osgl/api/Font","content":"","keywords":"","version":null},{"title":"Types​","type":1,"pageTitle":"Font","url":"/osgl/api/Font#types","content":" ","version":null,"tagName":"h2"},{"title":"Glyph​","type":1,"pageTitle":"Font","url":"/osgl/api/Font#Glyph","content":"&lt;/&gt; type Glyph = number | buffer | {number} The representation of a letter in a font made with the converter exe provided with the module.  ","version":null,"tagName":"h3"},{"title":"Glyphs​","type":1,"pageTitle":"Font","url":"/osgl/api/Font#Glyphs","content":"&lt;/&gt; type Glyphs = {[string]: Glyph} A group of letters  ","version":null,"tagName":"h3"},{"title":"StoredFont​","type":1,"pageTitle":"Font","url":"/osgl/api/Font#StoredFont","content":"&lt;/&gt; type StoredFont = { version: string, letters: Glyphs } The representation of a font made with the converter exe provided with the module.  ","version":null,"tagName":"h3"},{"title":"Font​","type":1,"pageTitle":"Font","url":"/osgl/api/Font#Font","content":"&lt;/&gt; type Font = { glyphs: Glyphs, spacing: number, linePadding: number } A loaded font ","version":null,"tagName":"h3"},{"title":"Functions​","type":1,"pageTitle":"Font","url":"/osgl/api/Font#functions","content":" ","version":null,"tagName":"h2"},{"title":"Draw​","type":1,"pageTitle":"Font","url":"/osgl/api/Font#Draw","content":"&lt;/&gt; Font.Draw( self: types.Font, object: types.DrawableObject&lt;T&gt;,-- A DrawableObject text: string,-- The text to draw x: number,-- X position y: number,-- Y position color: types.Color-- The color of the text ) → Font-- Returns itself. Draws text at a specific location on-screen local OSGL = require(path.to.osgl) local Window = OSGL.Window local Font = OSGL.Font local color = OSGL.color -- Creates a Window with a size of 50x50 -- This window is a DrawableObject local myWindow = Window.new(path.to.instance, { sizeX = 50, sizeY = 50 }) local data = -- Reference to font local font = Front.from(data) font:Draw(myWindow, &quot;Hello!&quot;, 0, 0) -- Draw the font   ","version":null,"tagName":"h3"},{"title":"from​","type":1,"pageTitle":"Font","url":"/osgl/api/Font#from","content":"&lt;/&gt; Font.from( data: types.StoredFont-- The loaded font-date ) → Font-- Returns a new font. Creates a new font local OSGL = require(path.to.osgl) local Window = OSGL.Window local Font = OSGL.Font local color = OSGL.color -- Creates a Window with a size of 50x50 -- This window is a DrawableObject local myWindow = Window.new(path.to.instance, { sizeX = 50, sizeY = 50 }) local font = Font.from(data)  ","version":null,"tagName":"h3"},{"title":"Development environment","type":0,"sectionRef":"#","url":"/osgl/docs/dev-environment","content":"Development environment In this chapter, we'll set up your environment for using OSGL. All of the tools we'll use, such as the image-converter executable, are available on Windows and MacOS. The most important component you'll need is the actual OSGL module itself. You can download the latest version of the module from either the Github releases, the Roblox marketplace or the Wally Index. You can use Rojo to sync the Examples folder to view any examples showcased or referenced in this tutorial. By default, all scripts have their Enabled property set to false, so you'll need to enable the script to test them. These scripts are designed to be self-sufficient and will automatically create any necessary resources during runtime. If you have Rojo, it's a good idea to sync the Examples folder to try out OSGL. A good place to start is to try the example &quot;01-BlackScreen,&quot; which renders a black window. To start, create a LocalScript in your desired location (e.g., StarterPlayer/StarterPlayerScripts). Assuming the OSGL module has been placed in ReplicatedStorage, paste the following code into your newly created script to test if OSGL works. Don't worry if you don't understand it yet! Upon running the game, there should be a black ImageLabel in the center of your screen. local Players = game:GetService(&quot;Players&quot;) local ReplicatedStorage = game:GetService(&quot;ReplicatedStorage&quot;) local OSGL = require(ReplicatedStorage.OSGL) local Window = OSGL.Window local color = OSGL.color local player = Players.LocalPlayer assert(player) -- Define window dimensions local WIDTH = 420 local HEIGHT = 420 -- Create ImageLabel &amp; ScreenGui local ScreenGui = Instance.new(&quot;ScreenGui&quot;) ScreenGui.Parent = player.PlayerGui local ImageLabel = Instance.new(&quot;ImageLabel&quot;) ImageLabel.AnchorPoint = Vector2.new(0.5, 0.5) ImageLabel.Position = UDim2.fromScale(.5, .5) ImageLabel.Size = UDim2.fromOffset(WIDTH, HEIGHT) ImageLabel.Parent = ScreenGui -- Create the window local window = Window.new(ImageLabel, { sizeX = WIDTH, sizeY = HEIGHT }) window.targetFPS = 244 -- Draw a black screen and render window :Clear(color.BLACK) :Render() If the code above executed successfully, you are now ready to proceed with the tutorial and the script can be deleted.","keywords":"","version":"Next"},{"title":"Color","type":0,"sectionRef":"#","url":"/osgl/api/Color","content":"","keywords":"","version":null},{"title":"Types​","type":1,"pageTitle":"Color","url":"/osgl/api/Color#types","content":" ","version":null,"tagName":"h2"},{"title":"Color​","type":1,"pageTitle":"Color","url":"/osgl/api/Color#Color","content":"&lt;/&gt; type Color = number local OSGL = require(path.to.osgl) local color = OSGL.color ​ -- All other parameters are defaulted -- to 0, except for alpha, which is -- defaulted to 255. local myAwesomeRedColor = color.new(255)  ","version":null,"tagName":"h3"},{"title":"Properties​","type":1,"pageTitle":"Color","url":"/osgl/api/Color#properties","content":" ","version":null,"tagName":"h2"},{"title":"RED​","type":1,"pageTitle":"Color","url":"/osgl/api/Color#RED","content":"&lt;/&gt; Color.RED: Color A red color  ","version":null,"tagName":"h3"},{"title":"GREEN​","type":1,"pageTitle":"Color","url":"/osgl/api/Color#GREEN","content":"&lt;/&gt; Color.GREEN: Color A green color  ","version":null,"tagName":"h3"},{"title":"BLUE​","type":1,"pageTitle":"Color","url":"/osgl/api/Color#BLUE","content":"&lt;/&gt; Color.BLUE: Color A blue color  ","version":null,"tagName":"h3"},{"title":"WHITE​","type":1,"pageTitle":"Color","url":"/osgl/api/Color#WHITE","content":"&lt;/&gt; Color.WHITE: Color A white color  ","version":null,"tagName":"h3"},{"title":"BLACK​","type":1,"pageTitle":"Color","url":"/osgl/api/Color#BLACK","content":"&lt;/&gt; Color.BLACK: Color A black color  ","version":null,"tagName":"h3"},{"title":"YELLOW​","type":1,"pageTitle":"Color","url":"/osgl/api/Color#YELLOW","content":"&lt;/&gt; Color.YELLOW: Color A yellow color  ","version":null,"tagName":"h3"},{"title":"MAGENTA​","type":1,"pageTitle":"Color","url":"/osgl/api/Color#MAGENTA","content":"&lt;/&gt; Color.MAGENTA: Color A magenta color  ","version":null,"tagName":"h3"},{"title":"CYAN​","type":1,"pageTitle":"Color","url":"/osgl/api/Color#CYAN","content":"&lt;/&gt; Color.CYAN: Color A cyan color  ","version":null,"tagName":"h3"},{"title":"TRANSPARENT​","type":1,"pageTitle":"Color","url":"/osgl/api/Color#TRANSPARENT","content":"&lt;/&gt; Color.TRANSPARENT: Color A completely transparent color ","version":null,"tagName":"h3"},{"title":"Functions​","type":1,"pageTitle":"Color","url":"/osgl/api/Color#functions","content":" ","version":null,"tagName":"h2"},{"title":"new​","type":1,"pageTitle":"Color","url":"/osgl/api/Color#new","content":"&lt;/&gt; Color.new( r: number?, g: number?, b: number?, a: number? ) → Color-- Returns a color Value Creates a new color value. Values cannot be changed manually and must be changed via a function. local OSGL = require(path.to.osgl) local color = OSGL.color -- All other parameters are defaulted -- to 0, except for alpha, which is -- defaulted to 255. local myAwesomeRedColor = color.new(255)   ","version":null,"tagName":"h3"},{"title":"newRGB​","type":1,"pageTitle":"Color","url":"/osgl/api/Color#newRGB","content":"&lt;/&gt; Color.newRGB( r: number?, g: number?, b: number? ) → Color-- Returns a color Value Creates a new color value with the alpha channel being 255. Values cannot be changed manually and must be changed via a function. local OSGL = require(path.to.osgl) local color = OSGL.color -- All other parameters are defaulted -- to 0. local myAwesomeRedColor = color.newRGB(255)   ","version":null,"tagName":"h3"},{"title":"setR​","type":1,"pageTitle":"Color","url":"/osgl/api/Color#setR","content":"&lt;/&gt; Color.setR( c: Color,-- The color to edit r: number-- The new value ) → number Sets the 'r' channel of the color. local OSGL = require(path.to.osgl) local color = OSGL.color local c = color.setR(color.RED, 100) print(color.r(c)) -- Ouput: 100 For performance boost, if you're creating colors using only 1 or 2 channels, you should do: local almostRed = color.setR(color.BLACK, 100)   ","version":null,"tagName":"h3"},{"title":"setG​","type":1,"pageTitle":"Color","url":"/osgl/api/Color#setG","content":"&lt;/&gt; Color.setG( c: Color,-- The color to edit g: number-- The new value ) → number Sets the 'g' channel of the color. local OSGL = require(path.to.osgl) local color = OSGL.color local c = color.setG(color.GREEN, 100) print(color.g(c)) -- Ouput: 100 For performance boost, if you're creating colors using only 1 or 2 channels, you should do: local almostGreen = color.setG(color.BLACK, 100)   ","version":null,"tagName":"h3"},{"title":"setB​","type":1,"pageTitle":"Color","url":"/osgl/api/Color#setB","content":"&lt;/&gt; Color.setB( c: Color,-- The color to edit b: number-- The new value ) → number Sets the 'b' channel of the color. local OSGL = require(path.to.osgl) local color = OSGL.color local c = color.setB(color.BLUE, 100) print(color.b(c)) -- Ouput: 100 For performance boost, if you're creating colors using only 1 or 2 channels, you should do: local almostBlue = color.setB(color.BLACK, 100)   ","version":null,"tagName":"h3"},{"title":"setA​","type":1,"pageTitle":"Color","url":"/osgl/api/Color#setA","content":"&lt;/&gt; Color.setA( c: Color,-- The color to edit a: number-- The new value ) → number Sets the 'a' channel of the color. local OSGL = require(path.to.osgl) local color = OSGL.color local c = color.setA(color.TRANSPARENT, 100) print(color.a(c)) -- Ouput: 100 For performance boost, if you're creating colors using only 1 or 2 channels, you should do: local almostBlack = color.setA(color.TRANSPARENT, 100)   ","version":null,"tagName":"h3"},{"title":"read​","type":1,"pageTitle":"Color","url":"/osgl/api/Color#read","content":"&lt;/&gt; Color.read( rgbaColor: Color-- The color to read ) → {number} Reads the value of the color local OSGL = require(path.to.osgl) local color = OSGL.color -- All other parameters are defaulted to 0, except for alpha, -- which is defaulted to 255. local myAwesomeRedColor = color.new(255) print(color.read(myAwesomeRedColor)) -- Output: { 255, 0, 0, 255 }   ","version":null,"tagName":"h3"},{"title":"r​","type":1,"pageTitle":"Color","url":"/osgl/api/Color#r","content":"&lt;/&gt; Color.r( color: Color-- The color to read ) → number Reads the 'r' value of the color local OSGL = require(path.to.osgl) local color = OSGL.color -- All other parameters are defaulted to 0, except for alpha, -- which is defaulted to 255. local myAwesomeRedColor = color.new(255) print color.r(myAwesomeRedColor)) -- Ouput: 255   ","version":null,"tagName":"h3"},{"title":"g​","type":1,"pageTitle":"Color","url":"/osgl/api/Color#g","content":"&lt;/&gt; Color.g( color: Color-- The color to read ) → number Reads the 'g' value of the color local OSGL = require(path.to.osgl) local color = OSGL.color -- All other parameters are defaulted to 0, except for alpha, -- which is defaulted to 255. local myAwesomeRedColor = color.new(255) print color.g(myAwesomeRedColor)) -- Ouput: 0   ","version":null,"tagName":"h3"},{"title":"b​","type":1,"pageTitle":"Color","url":"/osgl/api/Color#b","content":"&lt;/&gt; Color.b( color: Color-- The color to read ) → number Reads the 'b' value of the color local OSGL = require(path.to.osgl) local color = OSGL.color -- All other parameters are defaulted to 0, except for alpha, -- which is defaulted to 255. local myAwesomeRedColor = color.new(255) print color.b(myAwesomeRedColor)) -- Ouput: 0   ","version":null,"tagName":"h3"},{"title":"a​","type":1,"pageTitle":"Color","url":"/osgl/api/Color#a","content":"&lt;/&gt; Color.a( color: Color-- The color to read ) → number Reads the 'a' value of the color local OSGL = require(path.to.osgl) local color = OSGL.color -- All other parameters are defaulted to 0, except for alpha, -- which is defaulted to 255. local myAwesomeRedColor = color.new(255) print(color.a(myAwesomeRedColor)) -- Ouput: 255   ","version":null,"tagName":"h3"},{"title":"tint​","type":1,"pageTitle":"Color","url":"/osgl/api/Color#tint","content":"&lt;/&gt; Color.tint( color1: Color,-- The color to tint color2: Color,-- The tint that will be applied factor: number-- How strong the tint is ) → number Tints the color towards the other color using a tint factor. A tint factor of 0 means color1 will be returned, while a tint factor of 1 means color2 will be returned. local OSGL = require(path.to.osgl) local color = OSGL.color local whiteTintedRed = color.tint(color.WHITE, color.RED, 0.5)  ","version":null,"tagName":"h3"},{"title":"Video","type":0,"sectionRef":"#","url":"/osgl/api/Video","content":"","keywords":"","version":null},{"title":"Types​","type":1,"pageTitle":"Video","url":"/osgl/api/Video#types","content":" ","version":null,"tagName":"h2"},{"title":"Video​","type":1,"pageTitle":"Video","url":"/osgl/api/Video#Video","content":"&lt;/&gt; interface Video { sizeX: number-- The videos width. sizeX: number-- The videos height. playbackFrame: number-- Which frame the video is playing. frameRate: number-- How many frames-per-second to display. playing: boolean-- Whether the video is playing or not. loop: boolean-- Whether the video should loop after finishing. frames: {buffer}-- A set of DrawableObject that represent the videos frames. PlaySync: ( self: Video&lt;T&gt;, callback: (texture: Texture&lt;T&gt;) → () ) → Video&lt;T&gt; PlayAsync: ( self: Video&lt;T&gt;, callback: (texture: Texture&lt;T&gt;) → () ) → Video&lt;T&gt; Stop: (self: Video&lt;T&gt;) → Video&lt;T&gt; GetFrame: ( self: Video&lt;T&gt;, frame: number ) → Texture&lt;T&gt; GetBufferOfFrame: ( self: Video&lt;T&gt;, frame: number ) → buffer Previous:: (self: Video&lt;T&gt;) → Video&lt;T&gt; Next:: (self: Video&lt;T&gt;) → Video&lt;T&gt; } An animatable set of DrawableObject that represents a video. local OSGL = require(path.to.osgl) local Window = OSGL.Window local Video = OSGL.Video local Texture = OSGL.Texture ​ -- Creates a Window with a size of 50x50 -- This window is a DrawableObject local myWindow = Window.new(path.to.instance, { sizeX = 50, sizeY = 50 }) ㅤ local frames = -- Reference to texture-data local video = Video.from(frames) video.frameRate = 60 video.loop = true video:PlaySync(function(texture) Texture.draw(myWindow, texture, 0, 0) myWindow:Render() end)  ","version":null,"tagName":"h3"},{"title":"Properties​","type":1,"pageTitle":"Video","url":"/osgl/api/Video#properties","content":" ","version":null,"tagName":"h2"},{"title":"sizeX​","type":1,"pageTitle":"Video","url":"/osgl/api/Video#sizeX","content":"&lt;/&gt; Video.sizeX: number The videos width in pixels.  ","version":null,"tagName":"h3"},{"title":"sizeY​","type":1,"pageTitle":"Video","url":"/osgl/api/Video#sizeY","content":"&lt;/&gt; Video.sizeY: number The videos height in pixels.  ","version":null,"tagName":"h3"},{"title":"playbackFrame​","type":1,"pageTitle":"Video","url":"/osgl/api/Video#playbackFrame","content":"&lt;/&gt; Video.playbackFrame: number The frame the video is currently displaying  ","version":null,"tagName":"h3"},{"title":"frameRate​","type":1,"pageTitle":"Video","url":"/osgl/api/Video#frameRate","content":"&lt;/&gt; Video.frameRate: number The videos &quot;FPS&quot; (frames per second).  ","version":null,"tagName":"h3"},{"title":"playing​","type":1,"pageTitle":"Video","url":"/osgl/api/Video#playing","content":"&lt;/&gt; Video.playing: boolean Whether the video is currently playing.  ","version":null,"tagName":"h3"},{"title":"loop​","type":1,"pageTitle":"Video","url":"/osgl/api/Video#loop","content":"&lt;/&gt; Video.loop: boolean Whether the video should loop after finishing  ","version":null,"tagName":"h3"},{"title":"frames​","type":1,"pageTitle":"Video","url":"/osgl/api/Video#frames","content":"&lt;/&gt; Video.frames: {buffer} A set of DrawableObject that represent the videos frames. ","version":null,"tagName":"h3"},{"title":"Functions​","type":1,"pageTitle":"Video","url":"/osgl/api/Video#functions","content":" ","version":null,"tagName":"h2"},{"title":"PlaySync​","type":1,"pageTitle":"Video","url":"/osgl/api/Video#PlaySync","content":"&lt;/&gt; Video.PlaySync( self: types.Video&lt;T&gt;, callback: (texture: Texture) → ()-- A callback function that will be ran every frame, returning the current frame as a Texture. ) → Video-- Returns itself. Plays a video syncronously. The callback will be ran every frame and provides the current frame as a Texture. local OSGL = require(path.to.osgl) local Window = OSGL.Window local Video = OSGL.Video local Texture = OSGL.Texture -- Creates a Window with a size of 50x50 -- This window is a DrawableObject local myWindow = Window.new(path.to.instance, { sizeX = 50, sizeY = 50 }) local frames = -- Reference to texture-data local video = Video.from(frames) video.frameRate = 60 video.loop = true -- Plays the video syncronously, rendering -- to `myWindow` every frame video:PlaySync(function(texture) Texture.draw(myWindow, texture, 0, 0) myWindow:Render() end)   ","version":null,"tagName":"h3"},{"title":"PlayAsync​","type":1,"pageTitle":"Video","url":"/osgl/api/Video#PlayAsync","content":"&lt;/&gt; Video.PlayAsync( self: types.Video&lt;T&gt;, callback: (texture: Texture) → ()-- A callback function that will be ran every frame, returning the current frame as a Texture. ) → Video-- Returns itself. Plays a video asyncronously. The callback will be ran every frame and provides the current frame as a Texture. local OSGL = require(path.to.osgl) local Window = OSGL.Window local Video = OSGL.Video local Texture = OSGL.Texture -- Creates a Window with a size of 50x50 -- This window is a DrawableObject local myWindow = Window.new(path.to.instance, { sizeX = 50, sizeY = 50 }) local frames = -- Reference to texture-data local video = Video.from(frames) video.frameRate = 60 video.loop = true -- Plays the video asyncronously, rendering -- to `myWindow` every frame video:PlayAsync(function(texture) Texture.draw(myWindow, texture, 0, 0) myWindow:Render() end) print(&quot;This code will run while the video is playing!&quot;)   ","version":null,"tagName":"h3"},{"title":"Next​","type":1,"pageTitle":"Video","url":"/osgl/api/Video#Next","content":"&lt;/&gt; Video.Next(self: types.Video&lt;T&gt;) → Video-- Returns itself. Skips to the next frame. Goes to the first frame if loop is enabled. local OSGL = require(path.to.osgl) local Window = OSGL.Window local Video = OSGL.Video local Texture = OSGL.Texture -- Creates a Window with a size of 50x50 -- This window is a DrawableObject local myWindow = Window.new(path.to.instance, { sizeX = 50, sizeY = 50 }) local frames = -- Reference to texture-data local video = Video.from(frames) video.frameRate = 60 video.loop = true -- Plays the video syncronously, rendering -- to `myWindow` every frame video:PlaySync(function(texture) Texture.draw(myWindow, texture, 0, 0) if video.playbackFrame == 10 then -- Skip the frame video:Next() end end)   ","version":null,"tagName":"h3"},{"title":"Previous​","type":1,"pageTitle":"Video","url":"/osgl/api/Video#Previous","content":"&lt;/&gt; Video.Previous(self: types.Video&lt;T&gt;) → Video-- Returns itself. Goes to the previous frame. Does not go to the last frame if loop is enabled. local OSGL = require(path.to.osgl) local Window = OSGL.Window local Video = OSGL.Video local Texture = OSGL.Texture -- Creates a Window with a size of 50x50 -- This window is a DrawableObject local myWindow = Window.new(path.to.instance, { sizeX = 50, sizeY = 50 }) local frames = -- Reference to texture-data local video = Video.from(frames) video.frameRate = 60 video.loop = true -- Plays the video syncronously, rendering -- to `myWindow` every frame video:PlaySync(function(texture) Texture.draw(myWindow, texture, 0, 0) if video.playbackFrame == 10 then -- Go back a frame video:Previous() end end)   ","version":null,"tagName":"h3"},{"title":"Stop​","type":1,"pageTitle":"Video","url":"/osgl/api/Video#Stop","content":"&lt;/&gt; Video.Stop(self: types.Video&lt;T&gt;) → Video-- Returns itself. Stops the video playback and sets the current frame to the start. local OSGL = require(path.to.osgl) local Window = OSGL.Window local Video = OSGL.Video local Texture = OSGL.Texture -- Creates a Window with a size of 50x50 -- This window is a DrawableObject local myWindow = Window.new(path.to.instance, { sizeX = 50, sizeY = 50 }) local frames = -- Reference to texture-data local video = Video.from(frames) video.frameRate = 60 video.loop = true -- Plays the video syncronously, rendering -- to `myWindow` every frame video:PlaySync(function(texture) Texture.draw(myWindow, texture, 0, 0) if video.playbackFrame == 10 then -- Stop the playback video:Stop() end end)   ","version":null,"tagName":"h3"},{"title":"GetFrame​","type":1,"pageTitle":"Video","url":"/osgl/api/Video#GetFrame","content":"&lt;/&gt; Video.GetFrame( self: types.Video&lt;T&gt;, frame: number ) → Texture-- Returns the frame as a texture. Returns a specific frame as a Texture local OSGL = require(path.to.osgl) local Window = OSGL.Window local Video = OSGL.Video local Texture = OSGL.Texture -- Creates a Window with a size of 50x50 -- This window is a DrawableObject local myWindow = Window.new(path.to.instance, { sizeX = 50, sizeY = 50 }) local frames = -- Reference to texture-data local video = Video.from(frames) local frameTwo = video:GetFrame(2) -- frameTwo is a `Texture` object!   ","version":null,"tagName":"h3"},{"title":"GetBufferOfFrame​","type":1,"pageTitle":"Video","url":"/osgl/api/Video#GetBufferOfFrame","content":"&lt;/&gt; Video.GetBufferOfFrame( self: types.Video&lt;T&gt;, frame: number ) → Texture-- Returns the frame as a buffer. Returns a specific frame as a buffer local OSGL = require(path.to.osgl) local Window = OSGL.Window local Video = OSGL.Video local Texture = OSGL.Texture -- Creates a Window with a size of 50x50 -- This window is a DrawableObject local myWindow = Window.new(path.to.instance, { sizeX = 50, sizeY = 50 }) local frames = -- Reference to texture-data local video = Video.from(frames) local frameTwo = video:GetBufferOfFrame(2) -- frameTwo is a buffer object!   ","version":null,"tagName":"h3"},{"title":"new​","type":1,"pageTitle":"Video","url":"/osgl/api/Video#new","content":"&lt;/&gt; Video.new( width: number, height: number, frames: {buffer}? ) → Video-- The newly created Video object. Create a new Video object of the given dimensions, with an optional buffer. local OSGL = require(path.to.osgl) local Window = OSGL.Window local Video = OSGL.Video local Texture = OSGL.Texture -- Creates a Window with a size of 50x50 -- This window is a DrawableObject local myWindow = Window.new(path.to.instance, { sizeX = 50, sizeY = 50 }) -- Blank 500x500 video local video = Video.new(500, 500)   ","version":null,"tagName":"h3"},{"title":"from​","type":1,"pageTitle":"Video","url":"/osgl/api/Video#from","content":"&lt;/&gt; Video.from(collection: {types.FlagTexture | ModuleScript }) → Video-- The newly created Video object. Creates a new Video object from a collection of Texture objects. All frames must be the same size. local OSGL = require(path.to.osgl) local Window = OSGL.Window local Video = OSGL.Video local Texture = OSGL.Texture -- Creates a Window with a size of 50x50 -- This window is a DrawableObject local myWindow = Window.new(path.to.instance, { sizeX = 50, sizeY = 50 }) local frames = -- Reference to texture-data local video = Video.from(frames) -- video is a `Video` object!  ","version":null,"tagName":"h3"},{"title":"Window","type":0,"sectionRef":"#","url":"/osgl/api/Window","content":"","keywords":"","version":null},{"title":"Types​","type":1,"pageTitle":"Window","url":"/osgl/api/Window#types","content":" ","version":null,"tagName":"h2"},{"title":"WindowConfiguration​","type":1,"pageTitle":"Window","url":"/osgl/api/Window#WindowConfiguration","content":"&lt;/&gt; interface WindowConfiguration { sizeX: number-- The width of the OSGL window. The maximum width is 1024. Defaults to 100 sizeY: number-- The height of the OSGL window. The maximum height is 1024. Defaults to 100 } An OSGL window is the representation of the EditableImage instance. A window can be created by importing the OSGL 'window' submodule: local OSGL = require(path.to.osgl) local Window = OSGL.Window ​ -- Creates a Window with a size of 50x50 local myWindow = Window.new(path.to.instance, { sizeX = 50, sizeY = 50 })   ","version":null,"tagName":"h3"},{"title":"Window​","type":1,"pageTitle":"Window","url":"/osgl/api/Window#Window","content":"&lt;/&gt; interface Window { editableImage: EditableImage -- The actual EditableImage instance. targetFPS: number-- The FPS OSGL should aim to render at. renderers: {ImageLabel | ImageButton }-- A value used internally to keep track of what the Window is rendering too Render: (self: Window) → Window-- Renders the contents of the buffer Clear: ( self: Window, color: Color ) → Window-- Clears the window with a color Resize: ( self: Window, newWidth: number, newHeight: number ) → Window-- Resizes the window to a new size AddRenderer: ( self: Window, ...ImageLabel | ImageButton ) → Window-- Adds a new renderer instance RemoveRenderer: ( self: Window, ...ImageLabel | ImageButton ) → Window-- Removes a renderer instance Deserialize: ( self: Window, bfr: buffer, width: number, height: number ) → Window-- Safely replaces the current window's buffer with a new buffer by resizing it to the specified width and height, preventing errors during the update GetRelativeMouseToRenderer: ( self: Window, image: ImageLabel | ImageButton ) → ( boolean, number, number )-- Returns the mouse position relative to the renderer } An OSGL window is the representation of the EditableImage instance. A window can be created by importing the OSGL 'window' submodule: local OSGL = require(path.to.osgl) local Window = OSGL.Window ​ -- Creates a window from an existing EditableImage local myWindow = Window.from(path.to.editableImage)  ","version":null,"tagName":"h3"},{"title":"Properties​","type":1,"pageTitle":"Window","url":"/osgl/api/Window#properties","content":" ","version":null,"tagName":"h2"},{"title":"editableImage​","type":1,"pageTitle":"Window","url":"/osgl/api/Window#editableImage","content":"&lt;/&gt; Window.editableImage: EditableImage  The actual editableImage of the Window  ","version":null,"tagName":"h3"},{"title":"targetFPS​","type":1,"pageTitle":"Window","url":"/osgl/api/Window#targetFPS","content":"&lt;/&gt; Window.targetFPS: number The Window's Target FPS. Defaults to 60 window.targetFPS = 5 while task.wait() do window:Render() -- Renders at roughly 5FPS end  ","version":null,"tagName":"h3"},{"title":"Functions​","type":1,"pageTitle":"Window","url":"/osgl/api/Window#functions","content":" ","version":null,"tagName":"h2"},{"title":"Render​","type":1,"pageTitle":"Window","url":"/osgl/api/Window#Render","content":"&lt;/&gt; Window.Render(self: types.Window) → Window Renders the buffer to the EditableImage local OSGL = require(path.to.osgl) local Window = OSGL.Window -- Creates a new Window local myWindow = Window.new(path.to.parent, { sizeX = 50, sizeY = 50 }) -- Runs every heartbeat while task.wait() do -- *rendering magic* myWindow:Render() end   ","version":null,"tagName":"h3"},{"title":"Clear​","type":1,"pageTitle":"Window","url":"/osgl/api/Window#Clear","content":"&lt;/&gt; Window.Clear( self: types.Window, clearColor: Color?-- The color the screen will be cleared with ) → Window Clears the double-buffer with the given color or a transparent color local OSGL = require(path.to.osgl) local Window = OSGL.Window local color = OSGL.color -- Creates a new EditableImage local myWindow = Window.new(path.to.parent, { sizeX = 50, sizeY = 50 }) -- Runs every heartbeat while task.wait() do myWindow:Clear(color.GREEN) myWindow:Render() -- The above could also be chained as the followed: --[[ myWindow:Clear(color.GREEN) :Render() --]] end   ","version":null,"tagName":"h3"},{"title":"AddRenderer​","type":1,"pageTitle":"Window","url":"/osgl/api/Window#AddRenderer","content":"&lt;/&gt; Window.AddRenderer( self: types.Window, ...: ...(ImageLabel | ImageButton) -- The Images that will become renderers ) → Window Renders the current window to a set of Images with little-to-no performance impact. local OSGL = require(path.to.osgl) local Window = OSGL.Window local color = OSGL.color -- Creates a new EditableImage local myWindow = Window.new(path.to.parent, { sizeX = 50, sizeY = 50 }) myWindow:AddRenderer(path.to.imageA, path.to.imageB) -- imageA and imageB now both render the Window at the same time   ","version":null,"tagName":"h3"},{"title":"RemoveRenderer​","type":1,"pageTitle":"Window","url":"/osgl/api/Window#RemoveRenderer","content":"&lt;/&gt; Window.RemoveRenderer( self: types.Window, ...: ...(ImageLabel | ImageButton) -- The Images that will be removed if rendering the Window ) → Window Removes any renderers from any Images that are rendering the Window local OSGL = require(path.to.osgl) local Window = OSGL.Window local color = OSGL.color -- Creates a new EditableImage local myWindow = Window.new(path.to.parent, { sizeX = 50, sizeY = 50 }) myWindow:AddRenderer(path.to.imageA, path.to.imageB) -- imageA and imageB now both render the Window at the same time myWindow:RemoveRenderer(path.to.imageB) -- imageB no longer renders the Window   ","version":null,"tagName":"h3"},{"title":"Resize​","type":1,"pageTitle":"Window","url":"/osgl/api/Window#Resize","content":"&lt;/&gt; Window.Resize( self: types.Window, newWidth: number?,-- The new width of the window newHeight: number?-- The new height of the window ) → Window Resizes the window and its pixel buffer. This function may be resource intensive and is not made for constant use. May require a re-render, depending on the new size. After a window is resized, all renderers in window.renderers are added as a renderer local OSGL = require(path.to.osgl) local Window = OSGL.Window local color = OSGL.color -- Creates a new Window local myWindow = Window.new(path.to.parent, { sizeX = 50, sizeY = 50 }) myWindow:Resize(100) -- Changes width to 100 -- Runs every heartbeat while task.wait() do -- *rendering magic* myWindow:Render() end  ","version":null,"tagName":"h3"},{"title":"Errors","type":1,"pageTitle":"Window","url":"/osgl/api/Window##","content":"Type\tDescription&quot;Height&quot;\tThis error occurs if the height is smaller than 0 &quot;Width&quot;\tThis error occurs if the width is smaller than 0 &quot;Memory&quot;\tThis error occurs when the device does not have enough memory to resize the window  ","version":null,"tagName":"h3"},{"title":"Deserialize​","type":1,"pageTitle":"Window","url":"/osgl/api/Window#Deserialize","content":"&lt;/&gt; Window.Deserialize( bfr: buffer,-- The new buffer width: number?,-- The width of the buffer height: number?-- The height of the buffer ) → Window Safely replaces the current window's buffer with a new buffer by resizing it to the specified width and height, preventing errors during the update -- Save.luau local bfr, width, height = myWindow:Serialize() -- *save data* -- Load.luau local bfr, width, height = -- *load data* window:Deserialize(bfr, width, height)   ","version":null,"tagName":"h3"},{"title":"GetRelativeMouseToRenderer​","type":1,"pageTitle":"Window","url":"/osgl/api/Window#GetRelativeMouseToRenderer","content":"&lt;/&gt; Window.GetRelativeMouseToRenderer( self: types.Window, image: ImageLabel | ImageButton -- The renderer instance ) → ( boolean, number, number ) Returns a tuple describing the mouse position relative to the renderer from the top-left corner. The boolean represents if the mouse is in the renderer, and the following 2 numbers are the X and Y local OSGL = require(path.to.osgl) local Window = OSGL.Window local color = OSGL.color -- Creates a new Window local myWindow = Window.new(path.to.parent, { sizeX = 50, sizeY = 50 }) print(myWindow:GetRelativeMouseToRenderer(path.to.parent))   ","version":null,"tagName":"h3"},{"title":"new​","type":1,"pageTitle":"Window","url":"/osgl/api/Window#new","content":"&lt;/&gt; Window.new( parent: Instance ,-- The instance the EditableImage will be parented to config: WindowConfiguration?-- Optional configurations ) → Window-- Returns an OSGL window instance Creates an OSGL window by creating a new EditableImage instance at the given place. local OSGL = require(path.to.osgl) local Window = OSGL.Window ​ -- Creates a new Window local myWindow = Window.new(path.to.parent, { size = 50, size = 50 })  ","version":null,"tagName":"h3"},{"title":"Errors","type":1,"pageTitle":"Window","url":"/osgl/api/Window##","content":"Type\tDescription&quot;Typechecking&quot;\tThis error occurs when a required argument is not passed or the type is incorrect &quot;Permission&quot;\tThis error occurs when the owner of the place does not have the `EditableImage` feature enabled &quot;Memory&quot;\tThis error occurs when the device doesn't have enough memory to create the Window  ","version":null,"tagName":"h3"},{"title":"from​","type":1,"pageTitle":"Window","url":"/osgl/api/Window#from","content":"&lt;/&gt; Window.from( editableImage: EditableImage ,-- The existing EditableImage renderers: {ImageLabel | ImageButton? }-- An argument used internally to initially set any renderers ) → Window-- Returns an OSGL window instance Creates an OSGL window from an existing EditableImage. local OSGL = require(path.to.osgl) local Window = OSGL.Window ​ -- Creates a window from an existing EditableImage local myWindow = Window.from(path.to.editableImage)  ","version":null,"tagName":"h3"},{"title":"Errors","type":1,"pageTitle":"Window","url":"/osgl/api/Window##","content":"Type\tDescription&quot;Argument Type&quot;\tThis error occurs when a required argument is not passed or the type is incorrect &quot;Permission&quot;\tThis error occurs when the owner of the place does not have the `EditableImage` feature enabled &quot;Memory&quot;\tThis error occurs when the device doesn't have enough memory to create the Window  ","version":null,"tagName":"h3"},{"title":"fromAssetId​","type":1,"pageTitle":"Window","url":"/osgl/api/Window#fromAssetId","content":"&lt;/&gt; Window.fromAssetId( assetId: number-- The assetId that will be loaded ) → Window-- Returns an OSGL window instance Given an assetId, creates a Window. local OSGL = require(path.to.osgl) local Window = OSGL.Window ​ -- Creates a window from an assetId local myWindow = Window.fromAssetId(asset.id) -- use AddRenderers to add a renderer myWindow:AddRenderers(path.to.imageA)  ","version":null,"tagName":"h3"},{"title":"Errors","type":1,"pageTitle":"Window","url":"/osgl/api/Window##","content":"Type\tDescription&quot;Permission&quot;\tThis error occurs when the owner of the place does not have the `EditableImage` feature enabled &quot;Memory&quot;\tThis error occurs when the device doesn't have enough memory to create the Window  ","version":null,"tagName":"h3"},{"title":"fromBuffer​","type":1,"pageTitle":"Window","url":"/osgl/api/Window#fromBuffer","content":"&lt;/&gt; Window.fromBuffer( bfr: buffer,-- The buffer that will be loaded into the Window config: WindowConfiguration?-- Optional configurations ) → Window-- Returns an OSGL window instance Given a buffer, creates a Window. local OSGL = require(path.to.osgl) local Window = OSGL.Window ​ -- Creates a window from an assetId local myWindow = Window.fromBuffer(bfr, { sizeX = bufferWidth, sizeY = bufferHeight }) -- use AddRenderers to add a renderer myWindow:AddRenderers(path.to.imageA)  ","version":null,"tagName":"h3"},{"title":"Errors","type":1,"pageTitle":"Window","url":"/osgl/api/Window##","content":"Type\tDescription&quot;Permission&quot;\tThis error occurs when the owner of the place does not have the `EditableImage` feature enabled &quot;Memory&quot;\tThis error occurs when the device doesn't have enough memory to create the Window ","version":null,"tagName":"h3"},{"title":"Texture","type":0,"sectionRef":"#","url":"/osgl/api/Texture","content":"","keywords":"","version":null},{"title":"Types​","type":1,"pageTitle":"Texture","url":"/osgl/api/Texture#types","content":" ","version":null,"tagName":"h2"},{"title":"Texture​","type":1,"pageTitle":"Texture","url":"/osgl/api/Texture#Texture","content":"&lt;/&gt; type Texture = DrawableObject&lt;T&gt; A DrawableObject that represents a texture.  ","version":null,"tagName":"h3"},{"title":"FlagTexture​","type":1,"pageTitle":"Texture","url":"/osgl/api/Texture#FlagTexture","content":"&lt;/&gt; type FlagTexture = { version: string, width: number, height: number, pixels: buffer, } The representation of a texture made with the converter exe provided with the module. ","version":null,"tagName":"h3"},{"title":"Functions​","type":1,"pageTitle":"Texture","url":"/osgl/api/Texture#functions","content":" ","version":null,"tagName":"h2"},{"title":"from​","type":1,"pageTitle":"Texture","url":"/osgl/api/Texture#from","content":"&lt;/&gt; Texture.from( textureData: FlagTexture | ModuleScript -- The textureData ) → DrawableObject-- The loaded texture Creates a texture from textureData local OSGL = require(path.to.osgl) local Texture = OSGL.Texture local textureData = require(path.to.texture) local texture = Texture.from(textureData)   ","version":null,"tagName":"h3"},{"title":"new​","type":1,"pageTitle":"Texture","url":"/osgl/api/Texture#new","content":"&lt;/&gt; Texture.new( width: number,-- The texture's width height: number,-- The texture's height bfr: buffer?-- An optional buffer for textureData ) → DrawableObject-- The loaded texture Creates a texture of the given dimensions with an optional buffer local OSGL = require(path.to.osgl) local Texture = OSGL.Texture local texture = Texture.new(5, 10)   ","version":null,"tagName":"h3"},{"title":"draw​","type":1,"pageTitle":"Texture","url":"/osgl/api/Texture#draw","content":"&lt;/&gt; Texture.draw( object: DrawableObject,-- The object that the texture will be drawn onto texture: DrawableObject,-- The texture that will be drawn spriteX: number,-- The X position of where the texture will be drawn spriteY: number-- The y position of where the texture will be drawn ) → DrawableObject-- The final texture Draws a DrawableObject onto another DrawableObject local OSGL = require(path.to.osgl) local Texture = OSGL.Texture local textureData = require(path.to.texture) local secondTextureData = require(path.to.secondTexture) local textureA = Texture.from(textureData) local textureB = Texture.from(secondTextureData) -- Draw textureB on textureA at 0, 0 local textureC = Texture.draw(textureA, textureB, 0, 0)   ","version":null,"tagName":"h3"},{"title":"drawRotated​","type":1,"pageTitle":"Texture","url":"/osgl/api/Texture#drawRotated","content":"&lt;/&gt; Texture.drawRotated( object: DrawableObject,-- The object that the texture will be drawn onto texture: DrawableObject,-- The texture that will be drawn spriteX: number,-- The X position of where the texture will be drawn spriteY: number,-- The y position of where the texture will be drawn rotation: number-- The rotation of the texture ) → DrawableObject-- The final texture Draws a DrawableObject onto another DrawableObject with a rotation. The pivot is at the center of the DrawableObject local OSGL = require(path.to.osgl) local Texture = OSGL.Texture local textureData = require(path.to.texture) local secondTextureData = require(path.to.secondTexture) local textureA = Texture.from(textureData) local textureB = Texture.from(secondTextureData) -- Draw textureB on textureA at 0, 0, rotated 15 degrees local textureC = Texture.draw(textureA, textureB, 0, 0, 15)   ","version":null,"tagName":"h3"},{"title":"read​","type":1,"pageTitle":"Texture","url":"/osgl/api/Texture#read","content":"&lt;/&gt; Texture.read( texture: DrawableObject,-- The texture that the selection of pixels will be taken from xPos: number,-- The top-left X position of the selection yPos: number,-- The top-left Y position of the selection width: number,-- The width of the selection box height: number-- The height of the selection box ) → ( buffer, number, number )-- A tuple containing the buffer-data, the width, and height Reads a rectangular selection of pixels from a DrawableObject local OSGL = require(path.to.osgl) local Texture = OSGL.Texture local textureData = require(path.to.texture) local texture = Texture.from(textureData) -- Read a rectangular selection of pixels from 0, 5, with the -- selection being 10x15 (150 pixels, from 0, 5) local bfr, width, height = Texture.read(texture, 0, 5, 10, 15)   ","version":null,"tagName":"h3"},{"title":"scale​","type":1,"pageTitle":"Texture","url":"/osgl/api/Texture#scale","content":"&lt;/&gt; Texture.scale( texture: DrawableObject,-- The texture that will be enlarged scaleX: number,-- Scaling for x axis. Defaults to 1 scaleY: number-- Scaling for y axis. Defaults to 1 ) → DrawableObject-- The enlarged texture Scales a DrawableObject by the given amount local OSGL = require(path.to.osgl) local Texture = OSGL.Texture local textureData = require(path.to.texture) local texture = Texture.from(textureData) -- Enlarge `texture` by 5x on the X axis local enlargedTexture = Texture.scale(texture, 5)   ","version":null,"tagName":"h3"},{"title":"fromAssetId​","type":1,"pageTitle":"Texture","url":"/osgl/api/Texture#fromAssetId","content":"&lt;/&gt; Texture.fromAssetId( assetId: number-- The assetId that the texture will be ) → DrawableObject-- A finished texture that is the assetId Creates a DrawableObject (texture) from an assetId local OSGL = require(path.to.osgl) local Texture = OSGL.Texture local textureData = require(path.to.texture) local texture = Texture.fromAssetId(asset.id)  ","version":null,"tagName":"h3"},{"title":"Errors","type":1,"pageTitle":"Texture","url":"/osgl/api/Texture##","content":"Type\tDescription&quot;Memory&quot;\tThis error occurs when the device doesn't have enough memory to create the texture ","version":null,"tagName":"h3"},{"title":"Draw","type":0,"sectionRef":"#","url":"/osgl/api/Draw","content":"","keywords":"","version":null},{"title":"Functions​","type":1,"pageTitle":"Draw","url":"/osgl/api/Draw#functions","content":" ","version":null,"tagName":"h2"},{"title":"pixel​","type":1,"pageTitle":"Draw","url":"/osgl/api/Draw#pixel","content":"&lt;/&gt; Draw.pixel( object: DrawableObject, X: number, Y: number, color: Color ) → () Draws a singular pixel onto the DrawableObject. Ignores drawing mode. local OSGL = require(path.to.osgl) local Window = OSGL.Window local color = OSGL.color local draw = OSGL.draw -- Creates a new EditableImage local myWindow = Window.new(path.to.parent, { sizeX = 50, sizeY = 50 }) -- Draws a red pixel at 0, 0 draw.pixel(myWindow, 0, 0, color.RED)   ","version":null,"tagName":"h3"},{"title":"line​","type":1,"pageTitle":"Draw","url":"/osgl/api/Draw#line","content":"&lt;/&gt; Draw.line( object: DrawableObject, startX: number, startY: number, endX: number, endY: number, thickness: number, color: Color ) → () Draws a line onto the DrawableObject local OSGL = require(path.to.osgl) local Window = OSGL.Window local color = OSGL.color local draw = OSGL.draw -- Creates a new EditableImage local myWindow = Window.new(path.to.parent, { sizeX = 50, sizeY = 50 }) -- Draws a red line from 5, 5 to 10, 10 with a thickness of 2 draw.line(myWindow, 5, 5, 10, 10, 2, color.RED)   ","version":null,"tagName":"h3"},{"title":"rectangle​","type":1,"pageTitle":"Draw","url":"/osgl/api/Draw#rectangle","content":"&lt;/&gt; Draw.rectangle( object: DrawableObject, xPos: number, yPos: number, width: number, height: number, fill: Color?, stroke: Color?, strokeThickness: number?, rotation: number? ) → () Draws a rectangle onto the DrawableObject local OSGL = require(path.to.osgl) local Window = OSGL.Window local color = OSGL.color local draw = OSGL.draw -- Creates a new EditableImage local myWindow = Window.new(path.to.parent, { sizeX = 50, sizeY = 50 }) -- Draws a 5x5 red square at 0, 0 draw.rectangle(myWindow, 0, 0, 5, 5, color.RED)   ","version":null,"tagName":"h3"},{"title":"circle​","type":1,"pageTitle":"Draw","url":"/osgl/api/Draw#circle","content":"&lt;/&gt; Draw.circle( object: DrawableObject, centerX: number, centerY: number, radius: number, fill: Color?, stroke: Color?, strokeThickness: number?, rotation: number?-- This can only be viewed at low resolutions ) → () Draws a circle onto the DrawableObject local OSGL = require(path.to.osgl) local Window = OSGL.Window local color = OSGL.color local draw = OSGL.draw -- Creates a new EditableImage local myWindow = Window.new(path.to.parent, { sizeX = 50, sizeY = 50 }) -- Draws a red circle with a radius of 10 at 26, 26 draw.circle(myWindow, 26, 26, 10, color.RED)   ","version":null,"tagName":"h3"},{"title":"triangle​","type":1,"pageTitle":"Draw","url":"/osgl/api/Draw#triangle","content":"&lt;/&gt; Draw.triangle( object: DrawableObject, x1: number, y1: number, x2: number, y2: number, x3: number, y3: number, fill: Color?, stroke: Color?, strokeThickness: number? ) → () Draws a triangle onto the DrawableObject local OSGL = require(path.to.osgl) local Window = OSGL.Window local color = OSGL.color local draw = OSGL.draw -- Creates a new EditableImage local myWindow = Window.new(path.to.parent, { sizeX = 50, sizeY = 50 }) -- Draws a red triangle with the given points draw.triangle(myWindow, 0, 0, 5, 5, 10, 0, color.RED)   ","version":null,"tagName":"h3"},{"title":"polygon​","type":1,"pageTitle":"Draw","url":"/osgl/api/Draw#polygon","content":"&lt;/&gt; Draw.polygon( object: DrawableObject, points: {{number}}, fill: Color? ) → () Draws a polygon onto the DrawableObject local OSGL = require(path.to.osgl) local Window = OSGL.Window local color = OSGL.color local draw = OSGL.draw -- Creates a new EditableImage local myWindow = Window.new(path.to.parent, { sizeX = 50, sizeY = 50 }) -- Draws a red polygon with the given points draw.polygon(myWindow, { -- Points for a triangle { 0, 0 }, { 5, 5 }, { 10,0 }, }, color.RED)   ","version":null,"tagName":"h3"},{"title":"floodFill​","type":1,"pageTitle":"Draw","url":"/osgl/api/Draw#floodFill","content":"&lt;/&gt; Draw.floodFill( object: DrawableObject, x: number, y: number, fill: Color ) → () Replaces all adjacent pixels of the same color with a replacement local OSGL = require(path.to.osgl) local Window = OSGL.Window local color = OSGL.color -- Creates a new EditableImage local myWindow = Window.new(path.to.parent, { sizeX = 50, sizeY = 50 }) -- *draw something* -- Start flood-filling from (5, 5) myWindow:Draw():FloodFill(5, 5, color.RED)   ","version":null,"tagName":"h3"},{"title":"buffer​","type":1,"pageTitle":"Draw","url":"/osgl/api/Draw#buffer","content":"&lt;/&gt; Draw.buffer( object: DrawableObject, bfr: buffer, sizeX: number, sizeY: number, x: number, y: number ) → () Draws a buffer onto a DrawableObject local OSGL = require(path.to.osgl) local Window = OSGL.Window local color = OSGL.color -- Creates a new EditableImage local myWindow = Window.new(path.to.parent, { sizeX = 50, sizeY = 50 }) local sizeX, sizeY = 50, 50 local bfr = buffer.create(sizeX * sizeY * 4) -- Draw the buffer of sizeX, sizeY from 0, 0 myWindow:Draw():Buffer(bfr, sizeX, sizeY, 0, 0)   ","version":null,"tagName":"h3"},{"title":"setMode​","type":1,"pageTitle":"Draw","url":"/osgl/api/Draw#setMode","content":"&lt;/&gt; Draw.setMode(enum: DrawableObject) → () States whether shapes should draw with OverwritePixel, or Pixel. OverwritePixel is faster than Pixel, but does not support alpha blending. local OSGL = require(path.to.osgl) local Window = OSGL.Window local color = OSGL.color local draw = OSGL.draw local enum = OSGL.enum -- Creates a new EditableImage local myWindow = Window.new(path.to.parent, { sizeX = 50, sizeY = 50 }) -- Alpha-blending will be ignored all all shapes will use `OverwritePixel` draw.setMode(enum.DrawingMode.Overwrite) -- *draw something*  ","version":null,"tagName":"h3"},{"title":"DrawableObject","type":0,"sectionRef":"#","url":"/osgl/api/DrawableObject","content":"","keywords":"","version":null},{"title":"Types​","type":1,"pageTitle":"DrawableObject","url":"/osgl/api/DrawableObject#types","content":" ","version":null,"tagName":"h2"},{"title":"DrawableObject​","type":1,"pageTitle":"DrawableObject","url":"/osgl/api/DrawableObject#DrawableObject","content":"&lt;/&gt; interface DrawableObject { buffer: buffer-- The buffer of the object sizeX: number-- The width of the object. sizeY: number-- The height of the object. size: Vector2 -- The size of the object as a Vector2 Draw: (self: DrawableObject&lt;T&gt;) → DrawingContext&lt;T&gt;-- Returns the drawing context of the object TintRegion: ( self: DrawableObject&lt;T&gt;, tint: Color, factor: number, x: number, y: number, width: number, height: number ) → T-- Tints a region of pixels ReadPixel: ( self: T, x: number, y: number ) → Color-- Reads a pixel at the given X, Y WritePixel: ( self: T, x: number, y: number, color: Color ) → T-- Writes a pixel at the given X, Y OverwritePixel: ( self: T, x: number, y: number ) → T-- Writes a pixel at the given X, Y, ignoring the AlphaBlendMode. Faster than WritePixel Serialize: (self: T) → ( buffer, number, number )-- Returns the object's buffer, as well as its dimensions } A DrawableObject is an item that you can draw too. This can be a window, or a texture. local OSGL = require(path.to.osgl) local Window = OSGL.Window ​ -- Creates a Window with a size of 50x50 -- This window is a DrawableObject local myWindow = Window.new(path.to.instance, { sizeX = 50, sizeY = 50 })   ","version":null,"tagName":"h3"},{"title":"DrawingContext​","type":1,"pageTitle":"DrawableObject","url":"/osgl/api/DrawableObject#DrawingContext","content":"&lt;/&gt; interface DrawingContext { Pixel: ( self: DrawingContext&lt;V&gt;, x: number, y: number, color: Color ) → DrawingContext&lt;V&gt; Line: ( self: DrawingContext&lt;V&gt;, startX: number, startY: number, stopX: number, stopY: number, thickness: number, color: Color ) → DrawingContext&lt;V&gt; Rectangle: ( self: DrawingContext&lt;V&gt;, xPos: number, yPos: number, width: number, height: number, fill: Color?, stroke: Color?, strokeThickness: number?, rotation: number? ) → DrawingContext&lt;V&gt; Circle: ( self: DrawingContext&lt;V&gt;, centerX: number, centerY: number, radius: number, fill: Color?, stroke: Color?, strokeThickness: number?, rotation: number? ) → DrawingContext&lt;V&gt; Triangle: ( self: DrawingContext&lt;V&gt;, x1: number, y1: number, x2: number, y2: number, x3: number, y3: number, fill: Color?, stroke: Color?, strokeThickness: number? ) → DrawingContext&lt;V&gt; Polygon: ( self: DrawingContext&lt;V&gt;, corners: {{number}}, fill: Color ) → DrawingContext&lt;V&gt; FloodFill: ( self: DrawableObject&lt;V&gt;, x: number, y: number, fill: Color ) → DrawingContext&lt;V&gt; StopDrawing: (self: DrawingContext&lt;V&gt;) → V } The DrawingContext is a wrapper around [draw] that allows you to to call the functions with your DrawableObject already passed as the first argument. local OSGL = require(path.to.osgl) local Window = OSGL.Window local color = OSGL.color ​ -- Creates a Window with a size of 50x50 -- This window is a DrawableObject local myWindow = Window.new(path.to.instance, { sizeX = 50, sizeY = 50 }) myWindow:Draw():Pixel(1, 1, color.RED):StopDrawing()  ","version":null,"tagName":"h3"},{"title":"Properties​","type":1,"pageTitle":"DrawableObject","url":"/osgl/api/DrawableObject#properties","content":" ","version":null,"tagName":"h2"},{"title":"buffer​","type":1,"pageTitle":"DrawableObject","url":"/osgl/api/DrawableObject#buffer","content":"&lt;/&gt; DrawableObject.buffer: buffer The buffer of the object  ","version":null,"tagName":"h3"},{"title":"sizeX​","type":1,"pageTitle":"DrawableObject","url":"/osgl/api/DrawableObject#sizeX","content":"&lt;/&gt; DrawableObject.sizeX: number The width of the object  ","version":null,"tagName":"h3"},{"title":"sizeY​","type":1,"pageTitle":"DrawableObject","url":"/osgl/api/DrawableObject#sizeY","content":"&lt;/&gt; DrawableObject.sizeY: number The height of the object  ","version":null,"tagName":"h3"},{"title":"size​","type":1,"pageTitle":"DrawableObject","url":"/osgl/api/DrawableObject#size","content":"&lt;/&gt; DrawableObject.size: Vector2  The size of the object ","version":null,"tagName":"h3"},{"title":"Functions​","type":1,"pageTitle":"DrawableObject","url":"/osgl/api/DrawableObject#functions","content":" ","version":null,"tagName":"h2"},{"title":"WritePixel​","type":1,"pageTitle":"DrawableObject","url":"/osgl/api/DrawableObject#WritePixel","content":"&lt;/&gt; DrawableObject.WritePixel( x: number,-- X position y: number,-- Y position color: Color-- The color that will be written at the location ) → DrawableObject Writes a color to a certain pixel on a DrawableObject. The exact same as draw.pixel. local OSGL = require(path.to.osgl) local Window = OSGL.Window local color = OSGL.color -- Creates a new EditableImage local myWindow = Window.new(path.to.parent, { sizeX = 50, sizeY = 50 }) myWindow:WritePixel(0, 0, color.RED):Render()   ","version":null,"tagName":"h3"},{"title":"OverwritePixel​","type":1,"pageTitle":"DrawableObject","url":"/osgl/api/DrawableObject#OverwritePixel","content":"&lt;/&gt; DrawableObject.OverwritePixel( x: number,-- X position y: number,-- Y position color: Color-- The color that will be written at the location ) → DrawableObject Writes a color to a certain pixel on a DrawableObject, ignoring AlphaBlendMode local OSGL = require(path.to.osgl) local Window = OSGL.Window local color = OSGL.color -- Creates a new EditableImage local myWindow = Window.new(path.to.parent, { sizeX = 50, sizeY = 50 }) myWindow:OverwritePixel(0, 0, color.RED):Render()   ","version":null,"tagName":"h3"},{"title":"ReadPixel​","type":1,"pageTitle":"DrawableObject","url":"/osgl/api/DrawableObject#ReadPixel","content":"&lt;/&gt; DrawableObject.ReadPixel( x: number,-- X position y: number-- Y position ) → Color Reads a color on a window at the given location from the buffer local OSGL = require(path.to.osgl) local Window = OSGL.Window local color = OSGL.color -- Creates a new EditableImage local myWindow = Window.new(path.to.parent, { sizeX = 50, sizeY = 50 }) myWindow:WritePixel(0, 0, color.RED):Render() print( myWindow:ReadPixel(0, 0) -- 255 )   ","version":null,"tagName":"h3"},{"title":"Draw​","type":1,"pageTitle":"DrawableObject","url":"/osgl/api/DrawableObject#Draw","content":"&lt;/&gt; DrawableObject.Draw() → DrawingContext Returns the Window's DrawingContext local OSGL = require(path.to.osgl) local Window = OSGL.Window local color = OSGL.color -- Creates a new EditableImage local myWindow = Window.new(path.to.parent, { sizeX = 50, sizeY = 50 }) myWindow:Draw():Pixel(1, 1, color.RED):StopDrawing()   ","version":null,"tagName":"h3"},{"title":"TintRegion​","type":1,"pageTitle":"DrawableObject","url":"/osgl/api/DrawableObject#TintRegion","content":"&lt;/&gt; DrawableObject.TintRegion() → DrawableObject Tints a region of pixels local OSGL = require(path.to.osgl) local Window = OSGL.Window local color = OSGL.color -- Creates a new EditableImage local myWindow = Window.new(path.to.parent, { sizeX = 50, sizeY = 50 }) myWindow:TintRegion(color.RED, .5, 0, 0, 10, 10) -- Tint pixels from 0, 0, with the -- tinting region being 10x15 (150 pixels, from 0, 0) the color red, with -- a tinting factor of .5   ","version":null,"tagName":"h3"},{"title":"Serialize​","type":1,"pageTitle":"DrawableObject","url":"/osgl/api/DrawableObject#Serialize","content":"&lt;/&gt; DrawableObject.Serialize() → ( buffer, number, number ) Returns the object's buffer, as well as its width and height -- Save.luau local bfr, width, height = myWindow:Serialize() -- *save data* -- Load.luau local bfr, width, height = -- *load data* window:Deserialize(bfr, width, height)  ","version":null,"tagName":"h3"},{"title":"Introduction","type":0,"sectionRef":"#","url":"/osgl/docs/intro","content":"","keywords":"","version":"Next"},{"title":"About​","type":1,"pageTitle":"Introduction","url":"/osgl/docs/intro#about","content":" Welcome! This tutorial will introduce you to the basics of using the OSGL (Open-Source-Graphical-Library) API. OSGL provides a high-level abstraction of the EditableImage API, allowing you to interact directly with Roblox's EditableImage. This interface simplifies writing to EditableImages, resulting in better performance compared to other graphical frameworks like CanvasDraw.  OSGL is designed for programmers who seek high performance and flexibility, but this comes with the risk of erroneous code. For example, the ability to directly modify and set a window's buffer, which can lead to errors if not handled carefully. Additionally, OSGL offers tools to assist in development, such as the image-converter executable, which can create a Texture from a locally stored image.  Before you start, make sure you have the following prerequisites:  Roblox Studio &amp; A Roblox accountBasic knowledge of Luau - If you're new to Luau, there are plenty of resources available to help you learn.  This tutorial assumes you have a basic understanding of how to use Roblox Studio and basic knowledge of Luau. While prior knowledge of computer graphics concepts is not required, it may be helpful.  You can find various code examples in the examples folder of the GitHub repository.  ","version":"Next","tagName":"h2"},{"title":"Tutorial Structure​","type":1,"pageTitle":"Introduction","url":"/osgl/docs/intro#tutorial-structure","content":" We'll start by setting up your development environment for OSGL. Once that's ready, we'll create a window for rendering, covering the initialization and configuration of window properties.  Next, we'll guide you through rendering basic shapes and explain the drawing process in detail. We'll then move on to working with textures, including how to load and display them.  After that, we'll show you how to load and render video content while managing playback. Finally, we'll explain how OSGL works internally for those who want to change or modify the source code, giving you a clear understanding of its architecture.  By the end of this tutorial, you'll have a solid understanding of how to effectively use OSGL in your projects.  note This tutorial is intended to be a community effort; OSGL is still relatively new, and best practices are still evolving. If you have any feedback on the tutorial or the site itself, please don't hesitate to submit an issue or pull request to the GitHub repository. You can watch the repository to be notified of updates to the tutorial. You can learn more about contribution here. ","version":"Next","tagName":"h2"},{"title":"Migration","type":0,"sectionRef":"#","url":"/osgl/docs/Migrating/Migration","content":"Migration Welcome to the migration guide for transitioning from CanvasDraw to OSGL. This guide will walk you through the key steps and changes needed to migrate your existing codebase smoothly from CanvasDraw to OSGL. It's important to note that OSGL and CanvasDraw have different internal architectures. OSGL works differently from CanvasDraw, so you may need to refactor your code. In CanvasDraw, you create objects known as canvases with CanvasDraw.new(). In OSGL, you create a window, which you can read about here: local CanvasDraw = require(path) local OSGL = require(path) local Window = OSGL.Window -- OSGL is broken down into sub-modules that handle different aspects -- CanvasDraw CanvasDraw.new(Parent, Resolution, Color, Blur) -- OSGL Window.new(Parent, { sizeX = width, sizeY = height }) You can use the Window.new function to create the equivalent of a CanvasDraw canvas in OSGL. The OSGL code creates an EditableImage of size (sizeX, sizeY). All drawing methods can be directly accessed from the Canvas object in CanvasDraw. In OSGL, drawing is handled by different sub-modules (e.g., handling color, drawing, loading textures, etc.). Here is a comparison example: local CanvasDraw = require(path) local OSGL = require(path) local Window = OSGL.Window local color = OSGL.color local draw = OSGL.draw -- Draw a red pixel local Canvas = CanvasDraw.new(Frame, Vector2.new(150, 100)) Canvas:DrawPixel(Vector2.new(75, 50), Color3.new(1, 0, 0)) -- Draw a red pixel local window = Window.new(Frame, { sizeX = 150, sizeY = 100 }) draw.pixel(window, 76, 51, color.RED) It's also important to note two things: In OSGL, the top-left corner of the window is (0,0). In CanvasDraw, it is (1,1).The draw module is not needed to draw onto the window. Similar to CanvasDraw, you can draw any shape via method in OSGL, but OSGL allows you to chain these methods: local Canvas = CanvasDraw.new(Frame, Vector2.new(150, 100)) Canvas:DrawPixel(Vector2.new(75, 50), Color3.new(1, 0, 0)) Canvas:DrawLine(Vector2.new(5, 5), Vector2.new(145, 95), Color3.new(1, 0, 0), 2, true) local window = Window.new(Frame, { sizeX = 150, sizeY = 100 }) window :Draw() -- Opens a &quot;DrawingContext&quot;. :Pixel(76, 51, color.RED) :Line(6, 6, 146, 96, 2, color.RED) :StopDrawing() -- If you want to access the window's methods, you can use this. -- Otherwise, it is not needed! These methods are the same as the Draw methods, but they automatically pass the window as the first argument. You can find more about these methods in the API, or on the shapes page. Both Windows and Textures are known as DrawableObjects. A Window is a special form of a Texture, and a Texture is a buffer containing pixel data. This is similar to CanvasDraw's ImageData. To save a texture, save the buffer, sizeX, and sizeY (or just the size). Since it's a Texture, you can load it back into the game. This process is described in Serialization and Deserialization.","keywords":"","version":"Next"},{"title":"Drawing Shapes","type":0,"sectionRef":"#","url":"/osgl/docs/Shapes/drawing-shapes","content":"Drawing Shapes Below is a list of shapes in OSGL as of version 1.4b: Shape\tSupported\tSupports Rotation\tSupports Stroke\tNotesPixel\t✅\tN/A\tN/A Rectangle\t✅\t✅\t✅ Circle\t✅\t✅\t✅\tRotation is only visible at low resolutions. Lines\t✅\tN/A\t❌ Polygon\t✅\tN/A\t✅ Triangle\t✅\tN/A\t✅ Flood Fill\t✅\tN/A\tN/A\tDynamic shape that fills an area All shape-drawing functions are accessible through the draw sub-module of OSGL. The first argument for each function must be a DrawableObject, which can be either a Window or a Texture. Additionally, you will need to provide the necessary parameters to define the shape, such as its position, size, and color. Here is an example of how to draw a square, as defined by the documentation: local OSGL = require(path.to.osgl) local Window = OSGL.Window local color = OSGL.color local draw = OSGL.draw -- Creates a new EditableImage local myWindow = Window.new(path.to.parent, { sizeX = 50, sizeY = 50 }) -- Draws a 5x5 red square at 0, 0 draw.rectangle(myWindow, 0, 0, 5, 5, color.RED) Notes: Rotation: Most shapes support rotation, but in some cases (e.g., circles), the rotation is only visible at low resolutions. Stroke: For shapes that support strokes, you can define both the stroke color and thickness. However, strokes are entirely optional and can be omitted if not needed.","keywords":"","version":"Next"},{"title":"Custom OSGL Image Format","type":0,"sectionRef":"#","url":"/osgl/docs/Textures/custom-texture-format","content":"","keywords":"","version":"Next"},{"title":"Colors​","type":1,"pageTitle":"Custom OSGL Image Format","url":"/osgl/docs/Textures/custom-texture-format#colors","content":" Colors are stored as 32-bit unsigned integers (u32). This allows for compact representation and fast manipulation of colors as single numbers.  Each 32-bit color value consists of four 8-bit components: Red, Green, Blue, and Alpha (opacity). These components are packed into the 32-bit integer, with each component occupying one byte (8 bits).  ","version":"Next","tagName":"h2"},{"title":"Byte Layout of the Color​","type":1,"pageTitle":"Custom OSGL Image Format","url":"/osgl/docs/Textures/custom-texture-format#byte-layout-of-the-color","content":" The four components are stored in the following order, from the most significant byte to the least significant byte:  First byte (bits 1-8): Red (R)Second byte (bits 9-16): Green (G)Third byte (bits 17-24): Blue (B)Fourth byte (bits 25-32): Alpha (A)  This can be visualized as:  R\tG\tB\tA8 bits\t8 bits\t8 bits\t8 bits 1-8\t9-16\t17-24\t25-32  For example, consider a color with the following components:  Red (R): 255 (0xFF)Green (G): 128 (0x80)Blue (B): 64 (0x40)Alpha (A): 255 (0xFF)  These components would be packed into a 32-bit integer as follows:  Red (R): 255 (0xFF) -&gt; Occupies bits 24-31Green (G): 128 (0x80) -&gt; Occupies bits 16-23Blue (B): 64 (0x40) -&gt; Occupies bits 8-15Alpha (A): 255 (0xFF) -&gt; Occupies bits 0-7  The resulting 32-bit integer representation would be: 0xFF8040FF (4286595327). ","version":"Next","tagName":"h2"},{"title":"Loading Textures","type":0,"sectionRef":"#","url":"/osgl/docs/Textures/loading-textures","content":"Loading Textures To load file formats such as PNGs, WebPs, etc., OSGL uses its own external tool. The tool is bundled with OSGL on the github releases page, here, named image-converter (previously converter). Pick the one for your OS. If you don't know which to pick, feel free to ask us! note You can get help with the image-converter exe by running it in the command-prompt, with the -h flag! e.g: &gt; image-converter -h The image-converter turns these image formats into OSGLs custom image-format, which you can learn more about here. You can load textures into OSGL with the Texture.from function, which takes the texture generated by the image-converter: local OSGL = require(path.to.osgl) local Texture = OSGL.Texture ​ local txt = Texture.from(script.ModuleThatReturnsTexture) -- &quot;txt&quot; now contains OSGL-Texture data You can also create a blank texture of the given width, and height, with optional texture-data with the Texture.new function: local OSGL = require(path.to.osgl) local Texture = OSGL.texture ​ local txt = Texture.new(50, 50) -- Creates a 50x50 texture info A Texture is a DrawableObject, like a Window, meaning it can only be drawn too. You can edit a texture like any other window. This is because both belong to the super-class DrawableObject. This means anything you can draw to a Window, can also be drawn to a Texture. Or, in other words, a Window is also a Texture. warning Textures are expensive to load into memory! Once loaded however, they can be used everywhere. Always keep in mind some devices may not be able to load large textures. Textures, can, however, be loaded extremely fast, meaning you can load them in quick succession.","keywords":"","version":"Next"},{"title":"Loading Videos","type":0,"sectionRef":"#","url":"/osgl/docs/Videos/loading-videos","content":"Loading Videos To load a video format, such as an MP4, like a Texture, OSGL uses an external tool bundled with OSGL on the GitHub releases page, here, named video-converter. Choose the version for your OS. If unsure, feel free to ask us! note You can get help with the video-converter executable by running it in the command prompt with the -h flag, e.g.: &gt; video-converter -h The video-converter converts the video into a series of Textures. The structure of each texture is documented here. A video can be loaded via the Video.from function. Pass an array of Textures in order: local OSGL = require(path.to.osgl) local Video = OSGL.Video -- ... local video = Video.from({ frameOne, frameTwo }) -- &quot;video&quot; is a video of frameOne and frameTwo All frames must be the same size. If a frame isn't the same size as the others, it will be discarded. You can also create a blank video with the given dimensions and an optional buffer, allowing you to create videos during runtime: local OSGL = require(path.to.osgl) local Video = OSGL.Video local video = Video.new(50, 50) -- Creates a blank 50x50 video with no frames local video2 = Video.new(50, 50, {frameOne, frameTwo}) -- Creates a 50x50 video with frameOne and frameTwo warning High-resolution videos are even more expensive to load into memory than textures! Try to avoid storing them. Instead, consider optimizing your videos by reducing their resolution or compressing them before loading. This will help manage memory usage and improve performance.","keywords":"","version":"Next"},{"title":"Opening a Window","type":0,"sectionRef":"#","url":"/osgl/docs/rendering-to-a-window","content":"","keywords":"","version":"Next"},{"title":"Creating a canvas​","type":1,"pageTitle":"Opening a Window","url":"/osgl/docs/rendering-to-a-window#creating-a-canvas","content":" In OSGL, a Window is an EditableImage. OSGL is wrapper around this EditableImage that gives you an easy-to-use higher-level API that can still interact with the base EditableImage.  A Window needs to be able to render its content on some sort of Image, so create an ImageLabel within a ScreenGui in StarterGui, with its BackgroundTransparency set to 0. Ensure that the ScreenGui is named ScreenGui and the ImageLabel is named ImageLabel. This ImageLabel will act as your primary canvas for rendering graphics. Your StarterGui hierarchy should look like this:  &gt; StarterGui &gt; ScreenGui &gt; ImageLabel   To get a better view of the ImageLabel while in-game, you can place it in the center of the screen. This will help you see the rendered graphics more clearly instead of it being in a corner of the screen. Additionally, resizing the ImageLabel to a larger size, such as 420x420, can help you see what's rendered more easily.  In this image, the AnchorPoint property is set to .5, .5, with the position being .5, 0, .5, 0, and the size being 0, 420, 0, 420.  note Lower resolutions cause blurred images! If you're rendering at a low resolution, or just want a pixelated look, set the ResampleMode property of your ImageLabel to Pixelated!  ","version":"Next","tagName":"h2"},{"title":"Creating a Window​","type":1,"pageTitle":"Opening a Window","url":"/osgl/docs/rendering-to-a-window#creating-a-window","content":" Now that we have a canvas to work with, we can start programming. Create a LocalScript in a suitable location, such as StarterPlayer/StarterPlayerScripts.  The main OSGL module is divided into several sub-modules, each serving a different purpose. To create a Window, we need the Window sub-module. Let's import it:  local ReplicatedStorage = game:GetService(&quot;ReplicatedStorage&quot;) local OSGL = require(ReplicatedStorage.Packages.OSGL) local Window = OSGL.Window   The Window module offers multiple ways to create a Window. The following is an extract from the API:  Window.from: Creates an OSGL window from an existing EditableImage.Window.new: Creates an OSGL window by initializing a new EditableImage instance at the specified location.Window.fromAssetId: Creates a window given an assetId.Window.fromBuffer: Creates a window given a buffer.  Among the available options, Window.new is the most suitable for our needs. Since we do not have an existing EditableImage, this method will create one at the specified location. The function requires an Image, with an optional WindowConfiguration object:  local ReplicatedStorage = game:GetService(&quot;ReplicatedStorage&quot;) local Players = game:GetService(&quot;Players&quot;) local OSGL = require(ReplicatedStorage.Packages.OSGL) local Window = OSGL.Window local player = Players.LocalPlayer assert(player) local screenGui = player.PlayerGui:WaitForChild(&quot;ScreenGui&quot;) local imageLabel = screenGui.ImageLabel -- Create a Window with a size of 420x420. The size can be customized as needed, -- but it does not have to match the size of the ImageLabel. Note that Windows -- cannot exceed the maximum size of 1024x1024. local window = Window.new(imageLabel, { sizeX = 420, sizeY = 420 })   It's a good idea to use constants instead of hardcoded width and height numbers because we could be referring to these values a couple of times in the future:  local WIDTH = 420 local HEIGHT = 420 local window = Window.new(imageLabel, { sizeX = WIDTH, sizeY = HEIGHT })   Your full code should now look something like this:  local ReplicatedStorage = game:GetService(&quot;ReplicatedStorage&quot;) local Players = game:GetService(&quot;Players&quot;) local OSGL = require(ReplicatedStorage.OSGL) local Window = OSGL.Window local player = Players.LocalPlayer assert(player) -- Dimensions local WIDTH = 420 local HEIGHT = 420 local screenGui = player.PlayerGui:WaitForChild(&quot;ScreenGui&quot;) local imageLabel = screenGui.ImageLabel -- Create the window local window = Window.new(imageLabel, { sizeX = WIDTH, sizeY = HEIGHT })   By default, OSGL renders all windows at 60 FPS. You can change this value using the targetFPS property:  local window = Window.new(imageLabel, { sizeX = WIDTH, sizeY = HEIGHT }) window.targetFPS = 244   ","version":"Next","tagName":"h2"},{"title":"Drawing to a Window​","type":1,"pageTitle":"Opening a Window","url":"/osgl/docs/rendering-to-a-window#drawing-to-a-window","content":" To draw to the Window, use the Draw method, which returns a DrawingContext. To get the original Window object back, use StopDrawing:  -- Example.luau -- Object refers to `window` local object = window :Draw() -- Open a `DrawingContext` :SomeDrawingMethod() -- same as `draw.someDrawingMethod` :AnotherDrawingMethod() -- same as `draw.anotherDrawingMethod` :StopDrawing() -- Return the window   All methods in the Window module support method chaining. To fill the Window with a specific color, use the Clear method. OSGL uses its own custom color implementation. Import the color sub-module:  -- ... local OSGL = require(ReplicatedStorage.OSGL) local Window = OSGL.Window local color = OSGL.color -- ... window:Clear(color.BLACK) -- Fills the window with a black RGBA color   To see the changes on the Window, you need to use the Render method. This method applies all the drawing operations to the screen:  -- ... local OSGL = require(ReplicatedStorage.OSGL) local Window = OSGL.Window local color = OSGL.color -- ... window :Clear(color.BLACK) -- Fills the window with a black RGBA color :Render() -- Applies the changes to the screen   By calling Render, you ensure that all the drawing operations are displayed on the Window.  The full code should now look like:  local ReplicatedStorage = game:GetService(&quot;ReplicatedStorage&quot;) local Players = game:GetService(&quot;Players&quot;) local OSGL = require(ReplicatedStorage.OSGL) local Window = OSGL.Window local color = OSGL.color local player = Players.LocalPlayer assert(player) -- Dimensions local WIDTH = 420 local HEIGHT = 420 local screenGui = player.PlayerGui:WaitForChild(&quot;ScreenGui&quot;) local imageLabel = screenGui.ImageLabel -- Create the window local window = Window.new(imageLabel, { sizeX = WIDTH, sizeY = HEIGHT }) window.targetFPS = 244 window :Clear(color.BLACK) :Render()   Running this code should color the entire Window black:    And that's it! You've successfully rendered to a Window in OSGL. ","version":"Next","tagName":"h2"},{"title":"Rendering Textures","type":0,"sectionRef":"#","url":"/osgl/docs/Textures/rendering-textures","content":"","keywords":"","version":"Next"},{"title":"Drawing a Texture on Another Texture​","type":1,"pageTitle":"Rendering Textures","url":"/osgl/docs/Textures/rendering-textures#drawing-a-texture-on-another-texture","content":" In OSGL, a Texture is essentially a buffer, similar to a Window. To render a Texture onto another DrawableObject, such as a Window or another Texture, use the Texture.draw function:  local OSGL = require(path.to.osgl) local Texture = OSGL.Texture local textureData = require(path.to.texture) local secondTextureData = require(path.to.secondTexture) local textureA = Texture.from(textureData) local textureB = Texture.from(secondTextureData) -- Draw textureB on textureA at (0, 0) local textureC = Texture.draw(textureA, textureB, 0, 0)   ","version":"Next","tagName":"h2"},{"title":"Explanation​","type":1,"pageTitle":"Rendering Textures","url":"/osgl/docs/Textures/rendering-textures#explanation","content":" Two textures, textureA and textureB, are loaded using the Texture.from function.The Texture.draw function draws textureB onto textureA at position (0, 0). This operation returns a new Texture object, assigned to textureC.  ","version":"Next","tagName":"h3"},{"title":"Drawing a Texture onto a Window​","type":1,"pageTitle":"Rendering Textures","url":"/osgl/docs/Textures/rendering-textures#drawing-a-texture-onto-a-window","content":" You can also draw a Texture onto a Window, as it is a DrawableObject:  local OSGL = require(path.to.osgl) local Window = OSGL.Window local Texture = OSGL.Texture -- Create a new window local myWindow = Window.new(parent, { sizeX = 100, sizeY = 100 }) -- Load a texture local textureData = require(path.to.texture) local myTexture = Texture.from(textureData) -- Draw the texture onto the window at position (10, 10) Texture.draw(myWindow, myTexture, 10, 10) -- Render the window to display it on the screen myWindow:Render()   ","version":"Next","tagName":"h2"},{"title":"Example: Combining Textures with Layers​","type":1,"pageTitle":"Rendering Textures","url":"/osgl/docs/Textures/rendering-textures#example-combining-textures-with-layers","content":" Using this knowledge, you can layer multiple Texture objects onto a single DrawableObject:  local OSGL = require(path.to.osgl) local Texture = OSGL.Texture -- Load base texture and two additional layers local baseTextureData = require(path.to.baseTexture) local layer1Data = require(path.to.layer1) local layer2Data = require(path.to.layer2) local baseTexture = Texture.from(baseTextureData) local layer1 = Texture.from(layer1Data) local layer2 = Texture.from(layer2Data) -- Draw layer1 onto the base texture at (20, 20) Texture.draw(baseTexture, layer1, 20, 20) -- Draw layer2 onto the updated base texture at (40, 40) Texture.draw(baseTexture, layer2, 40, 40) -- Now baseTexture contains both layers combined!  ","version":"Next","tagName":"h2"},{"title":"Handling video playback","type":0,"sectionRef":"#","url":"/osgl/docs/Videos/video-playback","content":"","keywords":"","version":"Next"},{"title":"Overview​","type":1,"pageTitle":"Handling video playback","url":"/osgl/docs/Videos/video-playback#overview","content":" This guide covers how to handle video playback using OSGL. You will learn how to play videos both synchronously and asynchronously, manipulate video frames, and control playback using various methods provided by the Video class.  ","version":"Next","tagName":"h2"},{"title":"Playing a video​","type":1,"pageTitle":"Handling video playback","url":"/osgl/docs/Videos/video-playback#playing-a-video","content":" OSGL allows you to write your own video-playing logic. The callback argument of PlayAsync and PlaySync provides you with the current frame as a Texture, which you can manipulate as needed.  ","version":"Next","tagName":"h2"},{"title":"Playing a Video Synchronously​","type":1,"pageTitle":"Handling video playback","url":"/osgl/docs/Videos/video-playback#playing-a-video-synchronously","content":" You can play a video synchronously and draw each frame onto a window:  local OSGL = require(path.to.osgl) local Window = OSGL.Window local Video = OSGL.Video local Texture = OSGL.Texture local WIDTH = 800 local HEIGHT = 600 -- Create a new window local myWindow = Window.new(parent, { sizeX = WIDTH, sizeY = HEIGHT }) -- Load a video local myVideo = Video.from({ frameOne, frameTwo, frameThree }) -- Play the video synchronously and draw each frame onto the window myVideo:PlaySync(function(frame) Texture.draw(myWindow, frame, 0, 0) myWindow:Render() end)   In this example, for every frame of the video, the frame is drawn onto myWindow as a Texture, and then the window is rendered to display the frame.  ","version":"Next","tagName":"h3"},{"title":"Playing a Video Asynchronously​","type":1,"pageTitle":"Handling video playback","url":"/osgl/docs/Videos/video-playback#playing-a-video-asynchronously","content":" You can also play a video asynchronously, allowing other operations to run concurrently:  local OSGL = require(path.to.osgl) local Window = OSGL.Window local Video = OSGL.Video local Texture = OSGL.Texture local WIDTH = 800 local HEIGHT = 600 -- Create a new window local myWindow = Window.new(parent, { sizeX = WIDTH, sizeY = HEIGHT }) -- Load a video local myVideo = Video.from({ frameOne, frameTwo, frameThree }) -- Play the video asynchronously and draw each frame onto the window myVideo:PlayAsync(function(frame) Texture.draw(myWindow, frame, 0, 0) myWindow:Render() end) -- Perform other operations while the video is playing -- ...   In this asynchronous example, the video frames are drawn onto myWindow in the same way, but the video playback does not block other operations.  During playback, you can also call the other various methods of Video. Setting the playbackFrame to 0 will restart the video from the first frame. You can also use Previous and Next to go back and forward a frame. If Video.loop is true, Next will loop to the first frame after reaching the end. It is also possible to stop playback via the Stop method. You can learn more about these, among other functions, in the individual code examples attached to each function in the API. ","version":"Next","tagName":"h3"}],"options":{"id":"default"}}